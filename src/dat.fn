\ Core types operating directly on data

\ Note: declared by native
\ struct Slc [ dat:&U1  len:U2 ]

unty const NULL:&Any = 0

struct Buf  [ parent:Slc cap:U2 ]
struct CStr [ len:U2  dat:Arr[ ? U1] ]
struct Ring [ dat:&U1  head:U2  tail:U2  _cap:U2 ]

struct Stk  [ dat:&S  sp:U2  cap:U2 ]
struct Sll  [ next:&Self ]
struct SllS [ parent:Sll  v:S ]
struct Bst  [ l:&Self  r:&Self]
struct CBst [ parent:Bst  key:&CStr ]

use:Slc (
  meth get[self:&Self i:S -> U1] do (
    @ptrAdd(self.dat, i, self.len)
  )
)

\ ************
\ * Arena

struct Block  [
  const SIZE: U2 = 0x1000;
  dat:Arr[(SIZE - 4) U1];  bot:U2;  top:U2
]
struct BANode [ next:&BANode; prev:&BANode; block:&Block ]
struct BA     [ free:&BANode; len:S ]
struct BBA    [ ba:&BA; dat:&BANode ]

role Arena [
  absmeth drop [&Self]
  absmeth free [&Self, &Any, S\sz, U2\alignment -> &Slc ]
  absmeth alloc[&Self,       S\sz, U2\alignment -> &Any]
  absmeth maxAlloc[&Self -> S]
]

\ Note: method implementations are native (see fngi.c)
unty use:BBA (
  meth drop     [stk:&Self      ] do;
  meth free     [stk:&Self stk\dat:&Any stk\sz:S stk\alignment:U2 -> &Slc ] do;
  meth alloc    [stk:&Self              stk\sz:S stk\alignment:U2 -> &Any] do;
  meth maxAlloc [stk:&Self -> S ] do;
)

impl BBA:Arena {
  drop = &BBA.drop
  free = &BBA.free
  alloc = &BBA.alloc
  maxAlloc = &BBA.maxAlloc
}

\ ************
\ * File

struct BaseFile [
  ring: Ring \ buffer for reading or writing data
  code: U2   \ status or error (File_*)
]

role Reader [
  absmeth read   [&Self]
  absmeth asBase [&Self -> &BaseFile]
]
