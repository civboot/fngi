\ TODO: see notes/ufn.md for current thoughts

\ Bootstraps the fngi language.
\ Requires: boot.sp
\
\ Note: at this stage the language is severely restricted and several
\ pieces of the language are incomplete. Any CAPITAL items like FN, IF, LOOP
\ etc do not behave in the way their lower-case counterparts will behave.
\ Refer to boot.sp for all documentation.
\
\ DEVELOPER NOTES
\ Debug tooling at this stage is _extremely_ limited:
\   dv_log(val1, val2, identifier, 3\wsLen, 0x10) -> log some hex values to user
\   $setLogLvlSys(LOG_EXECUTE)                    -> log all calls
\   $setLogLvlSys(LOG_INSTR)                      -> log all instrs
$fngi  $STORE_PUB

\ **********
\ * [1] Extra core functions
syn FN =  panic(E_cToken)    \ prevent hanging =
syn FN )  panic(E_cParen)    \ prevent hanging )
pub syn        FN dv      notNow; $c1(DV); jmp:h1(d_vGet(colonRef))
pub pre inline FN memSet  $h1(2) dv:DV_memSet  ret; \ [&dst v len]   "dst = v"
pub pre inline FN memCmp  $h1(2) dv:DV_memCmp  ret; \ [&a &b len -> cmp]
pub pre inline FN memMove $h1(2) dv:DV_memMove ret; \ [&dst &src len] "dst = src"
\ pub pre        FN memMove        dv:DV_memMove ret; \ [&dst &src len] "dst = src"
pub pre        FN memClr 0 -> swp -> ret memSet(\a, \0, \len); \ [&a len] clear

$tAssert(isFnPre(dnode:memMove))  $tAssert(isFnInline(dnode:memMove))

pub pre FN dictRefMaybe \ [&root -> &node(nullable)]
  scan;  DV_comp_dGet -> dv:DV_comp; ret;

inline pre FN >     $h1(2) swp -> (\b < \a;)  ret;     \ [a b -> a > b]
inline pre FN <=    $h1(2) swp -> (\b >= \a;) ret;     \ [a b -> a <= b]
$(tAssert(2 > 1)  tAssertNot(2 > 2)  tAssert(2 <= 2)  tAssertNot(2 <= 1))

inline pre FN le_s  $h1(2) swp -> (\b ge_s \a;)  ret;  \ [a b -> a <= b]
inline pre FN gt_s  $h1(2) swp -> (\b lt_s \a;)  ret;  \ [a b -> a >= b]
$tAssert(gt_s(neg 1, neg 2)) $tAssertNot(gt_s(neg 2, neg 2))
$tAssert(gt_s(2, neg 7))
$tAssert(le_s(neg 2, neg 2)) $tAssert(le_s(neg 3, neg 2))
$tAssert(le_s(neg 1, 100))

pre FN compNext \ [asNow]
  $declVar(declL compFn,           0, RSIZE) $declEnd
  IF(\asNow) fnRef:_now;  ELSE  fnRef:baseCompFn;  END
  dup\fnRef -> updateCompFn(\fnRef) -> SET compFn \ {fnRef}
  xlw(\fnRef);  ret(GET compFn -> SET G_compFn)

\ **********
\ * [2] Inline slices: strings and tokens
pub syn FN |  notNow; \ [-> dat len] Define a string slice
  h1(SZ1 + SLC); heap; h1(0); \ {start}
  LOOP l0  charNextEsc; \ {start, char, unknownEscape}
    IF (\unknownEscape) assert(dup\char == 0c|, E_cStr);
    ELSE IF (dup\char == 0c|)
      drp\char; (heap - ovr\start) -> dec; \ {start len}
      assert(0xFF >= ovr\len, E_cNotFit);
      swp; sr1(\len, \start); ret;
    END END  h1(\char);
  AGAIN l0
$STORE_PRIV
FN helloWorld  ret |Hello World!|  \ [-> dat len]
$tAssertEq(helloWorld, 12); \ len == 12
$tAssertEq(ft1(dup\dat), 0cH);  $tAssertEq(ft1(inc(\dat)), 0ce); \ "He"

$STORE_PUB
pub pre FN slcCmp \ [&a aLen &b bLen -> cmp]
  $declVar(declL b,    TY_VAR_INPUT, RSIZE)
  $declVar(declL bLen, TY_VAR_INPUT, RSIZE)
  $declEnd
  IF(dup\aLen < GET bLen) drp; drp; ret(neg 1); END
  IF(   \aLen > GET bLen)      drp; ret(    1); END
  ret memCmp(\a, GET b, GET bLen)
pub pre FN slcEq  ret(slcCmp() == 0)
pub pre FN tokenEq ret(slcEq(\(...), tokenDat, tokenPlc))

$STORE_PRIV
FN helloBobby  ret |Hello Bobby!|  \ [-> dat len]
$tAssert   (slcEq(helloWorld, helloWorld))
$tAssertNot(slcEq(helloWorld, helloBobby))
$tAssertEq(slcCmp(helloWorld, helloWorld),     0) \ is equal
$tAssert(  slcCmp(helloWorld, 0, 42)      lt_s 0) \ different lengths
$tAssert(  slcCmp(helloWorld, helloBobby) gt_s 0) \ different contents

$STORE_PUB
FN SLC_DO     ret |do|
FN SLC_DOT    ret |.|
FN SLC_ELIF   ret |elif|
FN SLC_ELSE   ret |else|
FN SLC_EQ     ret |=|
FN SLC_PAREN  ret |(|
FN SLC_BRACK_O ret |[|
FN SLC_BRACK_C ret |]|

\ Scan and return whether the token equals. If it does, it was consumed.
pre FN consumeToken \(s:Slc -> hasToken:U1) ret (
  IF(scan; not tokenEq(\s)) tokenPlcSet(0); FALSE;
  ELSE  TRUE;  END
)

pre FN expectToken \ [<token/s> slc err -> &node(nullable)]
  $declVar(declL err, TY_VAR_INPUT, RSIZE)
  $declVar(declL node, 0, RSIZE)  $declEnd
  dictRefMaybe(0) -> SET node; \ {slc}
  assert(tokenEq(\slc), GET err)
  ret GET node

pre pub FN conEquals \ [`= token` asNow -> ?value]
  expectToken(SLC_EQ, E_needEqual) -> drp;
  ret compNext(\asNow)

pub syn FN const  \ `const token = token`
  $declVar(declL node, 0, RSIZE)  $declEnd
  notNow; dictAdd(0, 0) -> SET node;
  ret d_vSet(conEquals(TRUE), GET node)

$STORE_PRIV
const const42 = 0x42;         $tAssertEq(const42, 0x42)
const const49 = (0x42 + 7);   $tAssertEq(const49, 0x49)
$STORE_PUB

pre FN isTyped      ret( d_mGet(\node) msk C_TYPED )
pre FN d_tyGet \ {&DNode -> ty}
  assert(isTyped(dup\dnode), E_intern) -> ret ftoR:DN_ty;

pre FN d_tySet \ {&ty &DNode}
  assert(isTyped(dup\dnode), E_intern) -> ret sroR:DN_ty;

\ declTy:token(meta, ty) manually declare a dictionary entry
pub syn FN declTy ret ( \ {meta, ty}
  $declVar(declL node, 0, RSIZE) $declEnd
  notNow; colon; xx:dictAdd(0\v, C_TYPED\initalMeta) -> SET node;
  compNext(TRUE) -> d_tySet(\ty, GET node) -> d_mSet(\meta, GET node)
)

\ **********
\ * [XX] Type Scafolding and Native Type Implementation
\ Types are implemented from TY_DICT Dictionary Nodes, with meta:
\
\ 11-- -CCC C=category (Native, Bitmap, Struct, etc)
\
\ They also have C_TYPED set, which means they have a "ty" value:
\ * MOD / SUBMOD: C_TYPED must be 0. Value is the pointer to the sub-dictionary.
\ * NATIVE: a single tyItem byte (with C=0 N=0)
\ * else: a pointer to a tyStream
\
\ A tyStream starts with a single byte specifying the number of tyItems,
\ followed by tyItem elements (unaligned):
\    CN-- ----   C=constructed  N=named   \ first tyItem byte
\
\ If N=1, then the next bytes are the counted name (U1 length followed by data)
\
\ If C=0, it is not constructed, meaning it is a native type. In this case
\ the byte is:
\    0NZZ SRRR  N=named  Z=size  R=reference depth  S=signed
\ - (Z) The sizes are the same as instructions
\ - (R) The reference depth is a count of the number of `&` in the type.
\
\ If C=1 it is constructed, the meta is:
\     1NTT -RRR
\ N=named  T=SzI of type reference (pointer)  R=reference depth
\
\ Then there is T size bytes of the type reference.
const TY_DICT_MSK    = 0x07;
const TY_DICT_NATIVE = 0x00;
const TY_DICT_BITMAP = 0x01;
const TY_DICT_STRUCT = 0x02;
const TY_DICT_ENUM   = 0x03;
const TY_DICT_MOD    = 0x04;
const TY_DICT_SUBMOD = 0x05;

const META_CONSTRUCTED   = 0x80;
const META_NAMED         = 0x40;
const META_REF_MSK       = 0x07;
const META_NATIVE_SIGNED = 0x08;
const _native = (C_TYPED jn TY_DICT jn TY_DICT_NATIVE)

declTy:U1    (_native,                       SZ1)
declTy:U2    (_native,                       SZ2)
declTy:U4    (_native,                       SZ4)
declTy:Slot  (_native,                       SZR)
declTy:I1    (_native, META_NATIVE_SIGNED jn SZ1)
declTy:I2    (_native, META_NATIVE_SIGNED jn SZ2)
declTy:I4    (_native, META_NATIVE_SIGNED jn SZ4)
declTy:ISlot (_native, META_NATIVE_SIGNED jn SZR)

pre FN isTyDict     ret((d_mGet(\node) msk META_TY_MASK) == TY_DICT      )
pre FN isDictNative ret((d_mGet(\node) msk TY_DICT_MSK) == TY_DICT_NATIVE)
pre FN isDictStruct ret((d_mGet(\node) msk TY_DICT_MSK) == TY_DICT_STRUCT)
$tAssert(isTyDict(dnode:U1))
$tAssert(isDictNative(dnode:U1))

\ **********
\ * [XX] fn
\ fn myFn stk(a:U1 b:U2) inp c:U2; var i:U2; inp d:Ref
\ -> out(x:Ref y:Ref) do (
\   var i:U2 = 7;
\   ... code
\   var j:U2 = 10;
\   ... code
\ )
$STORE_PUB

pre FN isFnAndSyn \ {&node}
  retIfNot(dup)
  IF(not isTyFn(dup)) drp; ret FALSE END
  ret isFnSyn(\node);
$tAssertNot(isFnAndSyn(dnode:isFnAndSyn))
$tAssert   (isFnAndSyn(dnode:FN))

\ mskjn:MASK(a, b) set bits from a to b, clearing b with MASK first.
\ same as:     (a jn (b msk (inv MASK))
\ compiles as: a  b  (inv MASK)  %MSK %JN
large syn FN mskjn  ret (
  $declVar(declL asNow,    0, 1)
  $declVar(declL mask,     0, RSIZE) $declEnd
  \asNow -> SET asNow;
  inv(colonValue;) -> SET mask;
  dv_log(0xC01, 1, 0x10)
  xlw(GET G_compFn) \ {a b}
  IF(GET asNow) \b msk GET mask -> jn \a;
  ELSE          L(GET mask) h1(MSK) h1(JN) END
)
$tAssertEq(0x71, mskjn:0x3(1, 0x73))
$tAssertEq(0x71, mskjn:0x3(1, 0x72))

pub syn FN fn
  $declVar(declL meta,    0, RSIZE) $declEnd notNow;
  GET G_metaNext -> SET meta;
  dictRefMaybe(0) -> IF(dup\key) \ check if fn already exists
    assert(isFnDeclare(dup\key), E_cKey); \ {&key}
    d_vGet(dup\key) -> heap -> swp \ {&key heap &declFn}
    srBeR(\heap, \declFn) \ {&key}
    \ Make fn normal
    assertEq(
      d_mGet(dup\key) msk $L(0xFF - TY_FN_TY_MASK),
      GET meta jn TY_FN msk 0xFF, E_misDeclare)
    d_mSet(GET meta jn TY_FN, ovr\key)
  ELSE \ new function
    drp\key; tokenPlcSet(0); \ clear token
    dictAdd(0, GET G_metaNext jn TY_FN) \ {&key}
  END
  -> dv_log(dup\key, 0xF00F, 2, 0x10)
  -> _FN(\key)
  IF(isMetaFnDeclare(GET meta)) srBeR(0, bump(RSIZE, FALSE))  END

  LOOP l0
    dictRefMaybe(0) \ {&Node}
    IF(tokenEq(SLC_DO)) \ function body
      drp\node; declInpEnd; scan; single(FALSE);
      ret declFnEnd;
    END
    assert(isFnAndSyn(\node), E_fnSyn); single(FALSE) \ compile syn fns
  AGAIN l0

$STORE_PRIV
pre fn testFn \(a:Slot b:U2 -> b a) do ( swp -> ret; )
$(testFn(0x4321, 0x54321) -> tAssertEq(0x4321) -> tAssertEq(0x54321))

declare fn testDeclared do ()                      \ [-> U1]
$tAssert(isFnDeclare(dnode:testDeclared))
fn testDeclaredUsed       do ( ret testDeclared; ) \ [-> U1]
\declared fn testDeclared do ( ret 3; )            \ [-> U1]
$tAssertNot(isFnDeclare(dnode:testDeclared))
$tAssertEq(3, testDeclared;)  $tAssertEq(3, testDeclaredUsed;)

fn testDeclaredUsedAfter  do ( ret testDeclared; ) \ [-> U1]
$tAssertEq(3, testDeclaredUsedAfter;)

$STORE_PUB
\ **********
\ * [XX] function declaration syntax (var, inp, out)
declare large pre fn struct_sz \(s: &DNode -> sz:U2) do;

pre FN tySz \ {node:&DNode -> szBytes}
  assert(isTyDict(dup), 0xB001\E_intern)
  IF(isDictNative(dup)) ret szIToSz(d_tyGet(\node) msk SZ_MASK) END
  IF(isDictStruct(dup)) ret struct_sz(\node)                   END
  panic(E_unimpl) \ TODO: other types
$tAssertEq(1,     tySz(dnode:U1))
$tAssertEq(2,     tySz(dnode:I2))
$tAssertEq(RSIZE, tySz(dnode:ISlot))

pre FN countChr \ [chr -> numChr] and advance past them
  0\(chr, count) -> LOOP l0;
    swp \ {count chr}
    IF(dup\chr == peekChr) swp; inc(\count); tokenPlcSet(1);
    ELSE         drp\chr; ret \count; END
  AGAIN l0
$tAssertEq(countChr(0c&) & &&, 3)   $tAssertEq(countChr(0c&) 0)

FN parseTy \ [-> numRefs &DNode]
  $declVar(declL node,    0, RSIZE) $declEnd
  countChr(0c&); ret assert(isTyDict(dictRef(0) -> dup), E_needType)
$tAssertEq(parseTy &&U1, dnode:U1)   -> $tAssertEq(\numRefs, 2)
$tAssertEq(parseTy Slot, dnode:Slot) -> $tAssertEq(\numRefs, 0)

declare large pre fn _dotLocal do;

pre fn _varImpl do ret ( \ [meta]
  $declVar(declL compFn,  0, RSIZE)
  $declVar(declL meta, TY_VAR_INPUT, 2)
  $declVar(declL node,            0, RSIZE) $declEnd
  NULL -> SET node;
  IF(isFnAndSyn(dictRefMaybe(0)))
    ret single(FALSE) \ next token is syn, run it (it may run us)
  END
  tokenPlcSet(0); \ make dictRefMaybe a peek
  dv_log(GET meta, 0x900, 2, 0x10)
  IF(GET meta) \ a "real" variable. Parse ty and update dnode's meta and ty
    (GET meta jn C_TYPED jn C_LOCAL) -> SET meta \ ensure meta is C_TYPED
    ldictAdd(0\value, GET meta) -> SET node
    assertEq(GET meta, d_mGet(GET node), E_intern)
    GET node, 1\isLocal -> colon -> parseTy; \ {&Local isLocal=1 numRefs &Type}
    -> assert(ovr\numRefs < 4, E_cBadRefs)
    -> d_tySet(dup\type, GET node)
    -> ovr\numRefs jn GET meta -> SET meta   \ {&Local isLocal=1 numRefs &Type}
  ELSE \ a "fake" variable (i.e. `stk`)
    0, 1 -> _comment -> colon -> parseTy;    \ {NULL, isLocal=1, numRefs, &Type}
  END
  dv_log(0x910, 1, 0x10)

  IF(swp\numRefs) drp\type; RSIZE\sz
  ELSE            tySz(\type)\sz;  END \ {&Local isLocal szBytes}

  dv_log(0x920, 1, 0x10)
  IF(GET meta)
    dv_log(0x921, 1, 0x10)
    GET meta -> swp -> declVar;
  ELSE \stk
    drp; drp; drp;
  END
  dv_log(0x925, 1, 0x10)
  IF(GET meta and not(GET meta msk TY_VAR_INPUT)) \ if is `var`
    assert(GET node, E_intern);
    IF(consumeToken(SLC_EQ))
      tokenPlcSet(0)
      updateCompFn(fnRef:baseCompFn) -> SET compFn;
      _dotLocal(GET node, 0\synRefs, 0\synDerefs);
      GET compFn -> SET G_compFn;
    ELSE  tokenPlcSet(0)  END
  END

  dv_log(0x930, 1, 0x10)
)

fn _inp do ret (
  $declVar(declL compFn,  0, RSIZE)  $declEnd
  updateCompFn(fnRef:_inp) -> SET compFn;
  _varImpl($L(TY_VAR jn TY_VAR_INPUT))
  GET compFn -> SET G_compFn;
)
pub syn fn inp do ret (
  notNow; assert(getCState(C_FN_STATE) >= FN_STATE_STK, E_fnStateInp)
  setCState(FN_STATE_INP, C_FN_STATE) \ start inp state
  keyJnMeta(GET G_curNode, TY_FN_PRE)
  _inp;
)

pre inline FN tyItem_isConstructed \ (tyItem: &U1 -> U1)
  $h1(4) ft1(\tyItem) msk META_CONSTRUCTED; ret;
$tAssertNot(tyItem_isConstructed(d_tyGet(dnode:Slot)))

declare large pre fn conStructOffset do (); \ [&Node]
declare large pre fn deStructOffset do (); \ [&Node]

\ Called from compileInputs
\declared large pre fn compileTypedInput do ret ( \ [&Node]
  $declVar(declL nodeTy,  0, RSIZE)  $declEnd
  dv_log(dup\node, 0x093C, 2, 0x10)

  IF(isTyped(dup\node) and not(d_mGet(ovr\node) msk TY_VAR_REF))
    d_tyGet(dup\node) -> SET nodeTy
    dv_log(GET nodeTy, 0x093E, 2, 0x10)
    IF(isDictStruct(GET nodeTy))
      dv_log(0x093F, 1, 0x10)
      ret conStructOffset(d_tyGet(\node), 0\offset)
    END
  END
  _setImpl(\node)
)

$STORE_PRIV
\ test inp by truncating values
pre FN testInp  inp x:U1 $declEnd  ret(GET x)
$tAssertEq(testInp(0x101), 1)

pre FN testInp3  inp (x:U1  y:U2  z: &U1)  $declEnd
  ret(GET x, GET y, GET z)
$testInp3(0x101\U1, 0x12345\U2, 0x6789ABC\reference)
$tAssertEq(0x6789ABC)  $tAssertEq(0x2345)  $tAssertEq(0x01)

$STORE_PUB
fn _var do ret (
  $declVar(declL compFn,  0, RSIZE)  $declEnd
  updateCompFn(fnRef:_var) -> SET compFn;
  _varImpl(TY_VAR);  GET compFn -> SET G_compFn;
)
pub syn fn var do ret ( notNow;
  assert(getCState(C_FN_STATE) != FN_STATE_NO, E_fnStateVar); 
  _var;
)

fn _stk do ret (
  $declVar(declL compFn,  0, RSIZE)  $declEnd
  updateCompFn(fnRef:_stk) -> SET compFn;
  _varImpl(0);       GET compFn -> SET G_compFn;
)
pub syn fn stk do ret ( notNow;
  assertEq(getCState(C_FN_STATE), FN_STATE_STK, E_fnStateStk);
  keyJnMeta(GET G_curNode, TY_FN_PRE)
  _stk;
)

fn _out do ret (
  $declVar(declL compFn,  0, RSIZE)  $declEnd
  updateCompFn(fnRef:_out) -> SET compFn;
  _varImpl(0);       GET compFn -> SET G_compFn;
)
pub syn fn out do ret ( notNow;
  assert(getCState(C_FN_STATE) >= FN_STATE_STK, E_fnStateOut);
  setCState(FN_STATE_INP, C_FN_STATE) \ start inp state
  _out;
)

$STORE_PRIV
pre FN testVar \ x -> x + 1
  var x: U1 $declEnd  \x -> SET x; ret inc(GET x)
$tAssertEq(testVar(0x101), 2)

\ **********
\ * [4] if elif else, also $if ...
$STORE_PUB

\ cDat to Slc
fn cToSlc stk(cdat: &U1) -> out(dat: &U1, len: U2) do (
  ret (inc(dup\cdat) \(cdat, dat) -> swp -> ft1(\cdat))
)

\ TODO: I can remove recursion here and use a loop instead
large fn _if do ( \ [] recursive fn of `if`
  var h: &U1  $declEnd
  scan; single(FALSE) \ compile token after `if`
  xx:IF(FALSE\asNow) -> SET h \ compile IF
  expectToken(SLC_DO, E_cToken) -> drp;
  scan; single(FALSE); \ compile token after `do`
  IF(scan; tokenEq(SLC_ELIF))
    xx:ELSE(GET h, FALSE\asNow) -> SET h;
    _if; \ recurse for next elif/else clause
  ELSE IF(tokenEq(SLC_ELSE))
    xx:ELSE(GET h, FALSE\asNow) -> SET h;
    scan; single(FALSE);
  ELSE tokenPlcSet(0); \ reset token (peeking)
  END END 
  ret _END(GET h, dup)
)

fn _ifNowLogic stk(done: Slot) -> out(a: Slot) do (
  IF(dup\done) 
    _comment; expectToken(SLC_DO, E_cToken) -> drp; 
    _comment; ret \done; END
  drp\done;  scan; single(TRUE) -> \ifChk;
  expectToken(SLC_DO, E_cToken) -> drp;
  expectToken(SLC_PAREN, E_needParen) -> drp; tokenPlcSet(0);
  IF(\ifChk) compNext(FALSE); ret TRUE; END
  _comment; ret FALSE;
)

FN _ifNow \ [] fn of `if` for the asNow case
  _ifNowLogic(FALSE) \ {done}
  LOOP l0
  IF(scan; tokenEq(SLC_ELIF))
    _ifNowLogic(\done); AGAIN l0
  ELSE IF(tokenEq(SLC_ELSE))
    IF(\done) _comment;
    ELSE      compNext(FALSE)  END
  ELSE drp\done; tokenPlcSet(0); \ reset token (peeking)
  END END ret;

syn fn if do (IF(\asNow) _ifNow; ELSE _if; END ret;)

$STORE_PRIV
fn testIf2 stk(a:Slot) -> out(b:Slot) do ( \ converts 1->4, 2->7, else: 13
  if(dup == 1)  do (drp; ret 4)
  elif(\a == 2) do (     ret 7)
  ret (0x99)
)
$tAssertEq(testIf2(1), 4)      $tAssertEq(testIf2(2), 7)
$tAssertEq(testIf2(12), 0x99)  $assertNoWs

fn testManyElif inp(a:Slot) -> out(b:Slot) do ( \ [a -> b] ...
  if   (GET a < 0x10) do ret(0x1000 + GET a)
  elif (GET a < 0x20) do ret(0x2000 + GET a)
  elif (GET a < 0x30) do ret(0x3000 + GET a)
  elif (GET a < 0x40) do    (0x4000 + GET a) \ note: fallthrough
  else ret(0x10 + GET a);
  ret inc(\fallthrough);
)
$tAssertEq(testManyElif(0x5),  0x1005)  $tAssertEq(testManyElif(0x17), 0x2017)
$tAssertEq(testManyElif(0x22), 0x3022)  $tAssertEq(testManyElif(0x33), 0x4034)
$tAssertEq(testManyElif(0x55), 0x65)

$assertNoWs
$if(1) do ($0x42)           -> $tAssertEq(0x42)
$if(1) do ($0x42) else ($7) -> $tAssertEq(0x42)
$if 0  do ($0x42) else ($7) -> $tAssertEq(7)

$tAssertEq(if(1) do ($42) else ($3), 42)

$if 0 do ($0x42) elif(0) do ($3) elif(1) do ($0x44) else ($0x77)
$tAssertEq(0x44)

fn testIfNow do (ret($if(0) do (4) else (0x3F + 3)))  $assertNoWs
$tAssertEq(testIfNow, 0x42)


fn testMskJn stk(a:U2, b:U2) do ( ret mskjn:0x0F; )
$tAssertEq(0xF3, testMskJn(3,   0xFF))
$tAssertEq(0xFF, testMskJn(0xF, 0xF3))
$STORE_PUB

\ **********
\ * [5] struct
\ Example:
\     struct Foo ( a: U2; b: &U1 )
\
\ Structs are a TY_DICT node with a value to a root dictionary node
\ They are C_TYPED so have an extra "tyItems" field.

\ **********
\ *   [5.a] utilities
$STORE_PUB
const LOC_LOCAL = 0;
const LOC_PRIV  = 1;
const LOC_PUB   = 2;

fn locBBA stk(l:U1) do ( \ -> out(_:&BBA)
  if(dup\l == LOC_LOCAL) do (drp; ret REF G_bbaLocal)
  elif(\l == LOC_PRIV  ) do (     ret GET G_bbaPriv)
  ret GET G_bbaPub;
)

fn nameLoc -> out(loc:U1) do ( \ where location names are stored
  if(C_LOCAL    msk GET G_cstate) do ret LOC_LOCAL
  if(C_PUB_NAME msk GET G_cstate) do ret LOC_PUB else ret LOC_PRIV;
)

fn bumpName stk(size:U2, aligned:U1) -> out(_: &U1) do (
  ret BBA_bump(\size, \aligned, locBBA(nameLoc));
)


\ **********
\ *   [5.a] struct declaration
pre fn needSzI do ( \ (value -> neededSzI)
  IF(dup\value < 0x100  ) drp; ret SZ1; END
  IF(   \value <= 0xFFFF)      ret SZ2; END
                               ret SZ4;
)
$tAssertEq(SZ1, needSzI(0))      $tAssertEq(SZ1, needSzI(1))
$tAssertEq(SZ2, needSzI(0x100))  $tAssertEq(SZ2, needSzI(0xFFFF))
$tAssertEq(SZ4, needSzI(0x10000))

\ Store current token to name memory
fn storeToken -> out(cname: &U1) do (
  bumpName(tokenPlc + 1, FALSE) \ {&cDat}
  memMove(inc(dup;\cDat), tokenDat, tokenPlc) \ {&cDat}
  sr1(tokenPlc, ovr\cDat)
  ret \cDat;
)

$STORE_PRIV
fn testStoreToken do (
  scan; storeToken -> tAssertEq(ft1(dup\name), 7)
  ret tAssert(slcEq(cToSlc(\name), |testing|))
)
$testStoreToken testing

$STORE_PUB
pre fn _constructedMeta stk(numRefs:U1) inp(node:Slot) -> out(m:U1) do ret (
  \numRefs jn META_CONSTRUCTED jn needSzI(GET node)
)
$tAssertEq(_constructedMeta(2, 0x21),    0x82)
$tAssertEq(_constructedMeta(2, 0x4321),  0x92)
$tAssertEq(_constructedMeta(1, 0x54321), 0xA1)

large fn storeNodeBe stk(tyNode: &Slot) do ret (
  var tyRef: &U1;
  needSzI(dup\tyNode)                  \ {tyNode szI}
  -> bumpName(szIToSz(dup\szI), FALSE) \ {&tyNode szI &tyRef}
  -> dup -> SET tyRef -> swp           \ {&tyNode &tyRef szI}
  -> srBeSzI; GET tyRef
)

$STORE_PRIV
\ reason for dup: cache to check for overwrite
$tAssertEq(ftBe2(storeNodeBe(0x321) -> dup), 0x321)
$tAssertEq(ftBe4(storeNodeBe(0x54321)),      0x54321)
$tAssertEq(ftBe2(\cached321),                0x321)
$STORE_PUB

\ Compile a struct field, which may be a block of fields.
large fn _field do ret (
  var compFn: &Slot; updateCompFn(fnRef:_field) -> SET compFn;
  IF(isFnAndSyn(dictRefMaybe(0)))
    single(FALSE) \ next token is syn, run it (it may run us)
  ELSE
    var r\tyItems: &U1; d_tyGet(GET G_curNode) -> SET r\tyItems;
    sr1(inc ft1(GET r\tyItems), GET r\tyItems) \ struct.ty.numFields += 1
    bumpName(1, FALSE) -> SET r\tyItem;
    storeToken -> drp;
    colon; var tyNode: &Slot; parseTy -> SET tyNode; \ {numRefs}
    assert(dup\numRefs < 8, E_cBadRefs)  assert(isTyDict(GET tyNode), E_cNotType)
    if isDictNative(GET tyNode) do (
      assert(dup\numRefs + (d_tyGet(GET tyNode) msk META_REF_MSK)
             < 8, E_cBadRefs)
      sr1(\numRefs + d_tyGet(GET tyNode) jn META_NAMED, GET r\tyItem)
    ) else (
      \ store the tyItem meta, then the tyNode reference
      sr1(_constructedMeta(\numRefs, GET tyNode) jn META_NAMED, GET r\tyItem)
      storeNodeBe(GET tyNode) -> drp;
    )
  END
  GET compFn -> SET G_compFn;
)

\ Define a struct
large syn fn struct do (  notNow;
  dictAdd(NULL, $L(C_TYPED jn TY_DICT jn TY_DICT_STRUCT)) -> SET G_curNode;
  var tyItems: &U1; bumpName(1, FALSE\aligned) -> SET tyItems;
  d_tySet(GET tyItems, GET G_curNode);
  sr1(0\numFields, GET tyItems);
  _field;
  ret;
)

\ **********
\ *   [5.b] Important Structs and a few struct functions
pub struct DNode (
  l: &DNode;  r: &DNode;
  ckey: &U1;  v: Slot;    m: U2;
)

struct Slc      ( dat: &U1;  len: U2; )
struct FieldCtx ( offset:U2; sgMeta:U1, szI:U1, tyItem: &U1 )

const FC_tyItem = RSIZE;
const FC_sgMeta = 2;
const FC_szI = 3;


fn isTyStruct stk(node: &DNode) -> out(_:U1) do (
  isTyDict(dup\node) -> swp -> isDictStruct(\node) -> and -> ret;
)
$tAssertNot(isTyStruct(dnode:U1))
$tAssert   (isTyStruct(dnode:DNode))
$tAssertEq(5, ft1(d_tyGet(dnode:DNode))) \ DNode has 5 fields
$tAssertEq( \ field `l` is ref to DNode
  ft1(inc d_tyGet(dnode:DNode)),
  META_CONSTRUCTED + META_NAMED + needSzI(dnode:DNode) + 1\refs)
$tAssertEq(ft1(2 + d_tyGet(dnode:DNode)), 1)   \ "l" name has len=1
$tAssertEq(ft1(3 + d_tyGet(dnode:DNode)), 0cl)

\ **********
\ *   [5.b] Working with a tystream
\ Skip a name to get the type reference
$NEW_BLOCK_PUB
$NEW_BLOCK_PRIV
pre inline FN tyItem_refs \ {tyItem: &U1 -> refs:U1}
  $h1(3) ft1(\tyItem) msk META_REF_MSK; ret;

pre inline FN tyItem_isNamed \ {tyItem -> U1}
  $h1(4) ft1(\tyItem) msk META_NAMED; ret;

pre FN tyItem_skipName \ {tyItem: &U1 -> &U1}
  IF(tyItem_isNamed(dup\tyItem)) \ skip name
    ret (dup\tyItem + inc2 ft1(inc\tyItem;)) \ tyItem + nameCount+2
  END ret inc\tyItem;

\ Return the dictionary node for the tyItem
pre FN tyItem_node
  $declVar(declL tyItem, TY_VAR_INPUT, RSIZE) $declEnd
  assert(tyItem_isConstructed(GET tyItem), 0xB002\E_intern);
  ret ftBeSzI(tyItem_skipName(GET tyItem), ft1(GET tyItem) msk SZ_MASK)
$tAssertEq(tyItem_node(inc d_tyGet(dnode:DNode)), dnode:DNode)


\ Get the szI of a native tyItem
fn tyItem_nativeSzI stk(tyItem: &U1) -> out(refs:U1) do ret (
  assert(not tyItem_isConstructed(dup), E_intern);
  ft1(\tyItem) msk SZ_MASK
)

\ Get the size of a type item (native or struct).
fn tyItem_sz stk(tyItem: &U1) -> out(sz: U2) do ret (
  if(tyItem_refs(dup\tyItem)) do
    ( drp -> ret RSIZE; )
  if tyItem_isConstructed(dup\tyItem) do
    ret tySz(tyItem_node(\tyItem))
  szIToSz(ft1(\tyItem) msk SZ_MASK)
)


\ Point to the next tyItem in the tyItems.
fn tyItem_next inp(tyItem: &U1) -> out(_: &U1) do ret (
  tyItem_skipName(GET tyItem) \ {&out}
  if tyItem_isConstructed(GET tyItem) do (
    \out + szIToSz(ft1(GET tyItem) msk SZ_MASK) \ skip ref
  )
)

\ Manually assert all the field types in DNode, testing tyItem_(next|sz)
\ and struct at the same time.
$(
  inc d_tyGet(dnode:DNode) \ {tyItem0}  field l
  tAssertEq(tyItem_node(dup\tyItem0), dnode:DNode)
  tyItem_next(\tyItem0)     \ {tyItem1} field r
  tAssertEq(tyItem_node(dup\tyItem1), dnode:DNode)
  tyItem_next(\tyItem1)     \ {tyItem2} field ckey
  tAssertEq(ft1(dup\tyItem2), META_NAMED + SZ1 + 1)
  tAssertEq(tyItem_sz(dup\tyItem2), RSIZE)
  tyItem_next(\tyItem2)     \ {tyItem3} field v
  tAssertEq(ft1(dup\tyItem3), META_NAMED + SZR)
  tAssertEq(tyItem_sz(dup\tyItem3), RSIZE)
  tyItem_next(\tyItem3)     \ {tyItem4} field m
  tAssertEq(ft1(dup\tyItem4), META_NAMED + SZ2)
  tAssertEq(tyItem_sz(\tyItem4), 2)
)

\ **********
\ *   [XX.d] struct field walker and size

\ Bump the size by the add size.
\
\ This assumes that addSz behaves like a struct field and requires alignment.
fn bumpSz inp(curSz: U2, addSz: U2) -> out(newSz:U2) do (
  ret (align(GET curSz, reqAlign(GET addSz)) + GET addSz);
)
$tAssertEq(bumpSz(4, 1), 5)  $tAssertEq(bumpSz(4, 2), 6)
$tAssertEq(bumpSz(4, 3), 7)  $tAssertEq(bumpSz(5, 2), 8)
$tAssertEq(bumpSz(5, 4), 12) $tAssertEq(bumpSz(2, 8), 12)

\ Walk the tyItems, calling f for each one.
\
\ type of f [tyItem: &U1, ctx: &Any -> done:U1]
\
\ If f returns TRUE, return TRUE immediately.
\ Else, return FALSE after f has been executed with all tyItems.
fn tyItems_walk stk(tyItems: &U1) inp(ctx: &Slot, f: &Slot) -> out(done:U1)
do (
  \ type of f: fn [&tyItem &ctx -> stop:Bool]
  var numFields: U2; ft1(dup\tyItems) -> SET numFields;
  inc\(tyItems -> tyItem); LOOP l0  \ {tyItem}
    if(not GET numFields) do ( drp\tyItem; ret FALSE; )
    (dec GET numFields) -> SET numFields;
    if(xlw(dup\tyItem, GET ctx, GET f)) do ( drp\tyItem; ret TRUE; )
    tyItem_next(\tyItem);
  AGAIN l0
)

\ Walk a struct, updating the outSz for each tyItem.
fn _structSzWalker inp(tyItem: &U1, outSz: &U2) do (
  sr2(bumpSz(ft2(GET outSz), tyItem_sz(GET tyItem)), GET outSz);
  ret FALSE;
)

\declared large pre fn struct_sz stk(s: &DNode) -> out(sz: U2) do (
  var sz: U2; 0 -> SET sz;
  assert(isTyStruct(dup\s), 0xB003\E_intern);
  tyItems_walk(d_tyGet(\s), REF sz, fnRef:_structSzWalker) -> drp;
  ret GET sz;
)
$tAssertEq(18\0x12, struct_sz(dnode:DNode));
$tAssertEq(8,       struct_sz(dnode:FieldCtx));


\ **********
\ *   [XX.e] struct field name offsets
fn tyItem_cName stk(tyItem: &U1) -> out(cName: &U1) do ret (
  assert(tyItem_isNamed(dup\tyItem), 0xB004\E_intern) -> inc\tyItem;
)

\ Called by tyItems_walk for walking struct fields.
large fn _fieldNameWalker inp(tyItem: &U1, ctx: &FieldCtx) -> out(done:U1) do (
  if(tokenEq(cToSlc(tyItem_cName(GET tyItem)))) do (
    \ Found tyItem. Current offset is correct (after alignment)
    sroR:FC_tyItem(GET tyItem, GET ctx) \ ctx.tyItem = tyItem
    sr2( \ ctx.offset =
      align(ft2(GET ctx)\(ctx.offset), reqAlign(tyItem_sz(GET tyItem))),
      GET ctx)
    ret TRUE\done;
  )
  \ .ctx.offset = bumpSz(.ctx.offset, tySz(.tyItem))
  sr2(bumpSz(ft2(GET ctx), tyItem_sz(GET tyItem)), GET ctx);
  ret FALSE\done;
)

\ Get information about a struct field
large fn struct_fieldCtx stk(dnode: &DNode) inp(ctx: &FieldCtx) do ret (
  dv_log(dup\dnode, isTyStruct(dup\dnode), 0xC000, 3, 0x10)
  assert(isTyStruct(dup\dnode), E_type); scan;
  assert(
    tyItems_walk(d_tyGet(\node), GET ctx, fnRef:_fieldNameWalker),
    E_cNoKey);
)

fn consumeDot -> out(hasDot:U1) do (
  if(scan; not tokenEq(SLC_DOT)) do
    ( tokenPlcSet(0); ret FALSE; )
  ret TRUE;
)
$tAssert(consumeDot.)  $tAssertNot(consumeDot)

\ Return the node from the ctx and clear it (for safety)
large fn _ctxPopNode inp(ctx: &FieldCtx) -> out(_: &DNode) do ret (
  tyItem_node(ftoR:FC_tyItem(GET ctx)) \ {&Node}
  sroR:FC_tyItem(0, GET ctx)
)

\ Follow dots to find a field's offset and type
large fn struct_ctx inp(node: &DNode) -> out(offset:U2, tyItem: &U1) do (
  var ctxOffset: U2;  var ctxTyItem: &U1;
  0 -> SET ctxOffset; 0 -> SET ctxTyItem;
  if(not consumeDot) do ret (0, NULL); \ no dots, no offset or field
  struct_fieldCtx(GET node, REF ctxOffset) \ find first field
  LOOP l0
    \ Loop until there are no more dots. That field + offset is returned.
    if(not consumeDot) do ret (GET ctxOffset, GET ctxTyItem)
    tyItem_node(GET ctxTyItem) -> SET node;
    0 -> SET ctxTyItem;
    struct_fieldCtx(GET node, REF ctxOffset) \ find first field
  AGAIN l0
)
$tAssertEq(0,    struct_ctx(dnode:DNode).l -> drp\tyItem)
$tAssertEq(0x10, struct_ctx(dnode:DNode).m -> drp\tyItem)

\ **********
\ *   [XX] The dot compiler
\ The dot compiler allows us to use simpler syntax for (primarily) local
\ variables. It is the PRIMARY "syntax tree" of fngi, with the rest
\ being almost trivial concrete syntax around single tokens.
\
\ The dot compiler is invoked with the '.' token. For example:
\
\   .var          \ variable fetch
\   .var = (...)  \ variable store
\   .&var         \ variable reference (also function reference)
\   .@var         \ variable dereference
\   .@var = (...) \ variable dereference store
\
\   .var.field           \ variable field fetch
\   .var.field = (...)   \ variable field store
\   .&var.field          \ variable field reference
\   .@var.field = (...)  \ variable field dereference store

\ Okay here's what we do. The first token decides everything.
\ 1. If it's a local/global then it's just a lookup of field offset
\    (offset+type+references)
\ 2. Anything else, it's a dictionary lookup (NEVER a field)

\ IGNORE BELOW (probably)
\ Agh... I don't know how to do this.
\ WHAT exactly do I need to do? There are so many damn requirements here...
\ it is the OPPOSITE of simple!
\
\ Here's the first problem: I'm overloading this to do:
\ 1. local value and local field lookup (deep-struct as well!)
\ 2. local value and field setting (deep-struct as well!). I really don't think
\    this is even POSSIBLE without a syntax tree. If it is possible, it would be
\    such an enourmous pain I can't even begin!
\ 3. dictionary lookup, finding a function in a module (or struct!)
\ 4. god knows what else I wanted to do. Method lookup? Variant lookup?
\
\ This is WAY too much. A few notes:
\ 1. Following a bunch of dots on a TY_DICT is TRIVIAL. I could do that in
\    the base compiler whenever it encounters a dict type, and that is exactly what I
\    SHOULD do. It would effectively only find functions and constants.
\    - Alternatively: if the first item is a TY_DICT I could do that, otherwise
\      do locals/etc. But meh, I don't like that!
\ 2. '.' should just lookup value. Setting a value NEEDS to be done some other way,
\    other

\ Remove refs until there are 0 or 1, or until derefs are exhausted.
fn doPreDeref
    inp(offset:U1, refs:U1, derefs:U1) -> out(offset:U1, refs:U1, derefs:U1)
do (
  assert(GET refs >= GET derefs, 0x7086)
  LOOP l0
    dv_log(GET refs, GET derefs, 0x5100, 3, 0x10)
    \ FIXME: why is this working BETTER?
    \ if(GET refs < 2)
    if(GET derefs < 2) \ never do final deref
      do ret (GET offset, GET refs, GET derefs)
    if(GET offset) do (
      h1($L(SZR + FTO)) -> h1(GET offset); 0 -> SET offset
    ) else (
      h1($L(SZR + FT))
    )
    dec GET refs   -> SET refs;
    dec GET derefs -> SET derefs;
  AGAIN l0
)

\ Remove all refs until the last
fn autoDeref inp(offset:U1, refs:U1) -> out(offset:U1, newRefs:U1) do ret (
  LOOP l0
    dv_log(GET refs, 0x5200, 2, 0x10)
    if(GET refs < 2) do ret (GET offset, GET refs)
    if(GET offset) do (
      h1($L(SZR + FTO)); h1(GET offset); 0 -> SET offset
    ) else (
      h1($L(SZR + FT))
    )
    dec GET refs   -> SET refs;
  AGAIN l0
)

$STORE_PRIV
$(
  autoDeref(4, 0) -> swp -> tAssertEq(4) -> tAssertEq(0)
  autoDeref(4, 1) -> swp -> tAssertEq(4) -> tAssertEq(1)
  autoDeref(4, 2) -> swp -> tAssertEq(0) -> tAssertEq(1)
  autoDeref(4, 3) -> swp -> tAssertEq(0) -> tAssertEq(1)
)
$STORE_PUB

const SG_SETTER = 0x80;
const SG_DIRECT  = 0x40;

\ Return the szI of the field (tyItem) if native, else 0xFF (invalid).
\ If tyItem is NULL, return szI of node if native, else 0xFF
fn field_szI inp(node: &DNode, tyItem: &U1) -> out(szI:U1) do ret (
  if(GET tyItem) do (
    if(tyItem_isConstructed(GET tyItem)) do 0xFF \ invalid szI
    else tyItem_nativeSzI(GET tyItem)
  ) else (
    \ TODO: assert is type, handle functions
    if(isDictNative(GET node)) do (
      d_tyGet(GET node) msk SZ_MASK
    ) else 0xFF \ invalid szI
  )
)

fn directInstr stk(sgMeta:U1) -> out(instr:U1) do ret (
  if(\sgMeta msk SG_SETTER) do SRLL else FTLL
)
$tAssertEq(SRLL, directInstr(SG_SETTER))
$tAssertEq(FTLL, directInstr(0))

\ Given the type's szI and number of reference, return the correct size.
fn szIWithRefs stk(szI:U1, tyRefs: U1) -> out(szIOut:U1) do ret (
  if(\tyRefs) do (drp\szI; ret SZR) ret \szI;
)
$tAssertEq(SZ1, szIWithRefs(SZ1, 0))  $tAssertEq(SZR, szIWithRefs(SZ1, 1))

\ Perform a direct operation (i.e. get/set local).
\ - If no derefs, this finishes all get/set operations.
\ - With derefs, this sets up for gsDeref
\ Note: This clears ctx.offset=0 if it was used
large fn gsDirect
  inp(offset:U1, tyRefs:U1, hasDerefs:U1, ctx: &FieldCtx)
do ret (
  dv_log(GET offset, GET hasDerefs, 0x2000, 3, 0x10);
  \ If we are going to do a deref, we only fetch.
  \ Note: any parent refs cause an implicit deref.
  if(GET hasDerefs) do (
    assert(GET tyRefs, E_cBadDerefs);
    h1($L(SZR + FTLL));
    ret h1(GET offset);
  )
  szIWithRefs(fto1:FC_szI(GET ctx), GET tyRefs) \ {szI}
  assertSzI(dup\szI);
  \szI jn directInstr(fto1:FC_sgMeta(GET ctx)) \ {instr}
  dv_log(dup\instr, 0x2001, 2, 0x10);
  h1(\instr)
  h1(GET offset + ft2(GET ctx)\offset);
  sr2(0, GET ctx\offset) \ used ctx.offset, so clear it
)

\ Perform a get or set deref utilizing ctx:
\   .ctx.offset (also updated)
\   .ctx.sgMeta: SG_SETTER (note: ignores SG_DIRECT)
\   .ctx.szI
\ Note: this does NOT utilize tyItem
large fn gsDeref inp (tyRefs: U1, derefs: U1, ctx: &FieldCtx)
do (
  dv_log(GET tyRefs, GET derefs, 0xD0F0, 3, 0x10)
  doPreDeref(ft2(GET ctx)\offset, GET tyRefs, GET derefs)
  -> SET derefs -> SET tyRefs -> sr2(\offset, GET ctx)\setOffset
  retIfNot(GET derefs)
  dv_log(GET tyRefs, GET derefs, ft2(GET ctx), 0xD0F1, 4, 0x10)
  if(ft2(GET ctx)\offset) do (
    if(SG_SETTER msk fto1:FC_sgMeta(GET ctx)) do SRO else FTO
    \instr + szIWithRefs(fto1:FC_szI(GET ctx), dec GET tyRefs)
    dv_log(dup\instr, 0xD0F2, 2, 0x10)
    h1(\instr);
    ret h1(ft2(GET ctx)\offset);
  )
  if(SG_SETTER msk fto1:FC_sgMeta(GET ctx)) do SR else FT
  \instr + szIWithRefs(fto1:FC_szI(GET ctx), dec GET tyRefs)
  dv_log(dup\instr, 0xD0F3, 2, 0x10)
  ret h1(\instr)
)

\ Perform `.` for a local/global variable, walking the dots
\ i.e: `.myStruct.fieldStruct.field`
\ - Continue to add local offset (in Ctx) until a reference type is
\   encountered.
\declared large pre fn _dotLocal
    stk(node: &DNode, synRefs: U1, synDerefs: U1)
do (
  \ IMPORTANT: must be first for alignment
  var ctxOffset: U2;  var sgMeta:U1; var ctxSzI:U1; var ctxTyItem: &U1;
  var synDerefs: U1;  var synRefs: U1;  var node: &DNode;

  \synDerefs -> SET synDerefs;
  \synRefs -> SET synRefs;
  \node -> SET node;

  dv_log(0xD000, 1, 0x10)
  0 -> SET ctxOffset; NULL -> SET ctxTyItem;
  \ Extract metadata from node and use type instead.
  var varRefs: U1; d_mGet(GET node) msk TY_VAR_REF -> SET varRefs;
  var directOffset: U1; d_vGet(GET node) -> SET directOffset;
  SG_DIRECT -> SET sgMeta;
  d_tyGet(GET node) -> SET node;

  dv_log(GET varRefs, GET directOffset, 0xD002, 3, 0x10)
  consumeDot -> BREAK0 b0
  dv_log(0xD07, 0xD003, 2, 0x10)
  struct_fieldCtx(GET node, REF ctxOffset) \ find first field
  LOOP l0
    dv_log(GET ctxTyItem, GET ctxOffset, 0xD010, 3, 0x10)
    \ At this point there is either a local or a single-reference value.
    \ We need to get the next field. There are a few possibilities:
    \  1. There is no next field -> we break to handle the value.
    \  2. The next field item is an embedded struct -> we increment offset.
    \     This works whether isDirect is true/false
    \  3. The next field item is a reference. We update the number of
    \     references appropriately.
    consumeDot -> BREAK0 b1
    dv_log(0xD011, 1, 0x10)

    \ If isDirect (we have field of local struct) then we need to get the local
    \ offset to "convert" the value to a reference on the stack.
    \ Note: We don't decrement varRefs since the type on the stack has that
    \   number of references in front of it.
    \ Note2: the varRefs can become non-zero either from a local that is
    \   a reference `var s: &MyStruct` or from a field which is a reference
    \   `nonRef.aRef.b`
    if((SG_DIRECT msk GET sgMeta) and GET varRefs) do (
      h1($L(SZR + FTLL)) h1(GET ctxOffset)
      0 -> SET ctxOffset; GET sgMeta msk $L(inv SG_DIRECT) -> SET sgMeta;
    )
    autoDeref(GET ctxOffset, GET varRefs) -> SET varRefs -> SET ctxOffset;
    tyItem_node(GET ctxTyItem) -> SET node;
    0 -> SET ctxTyItem;
    struct_fieldCtx(GET node, REF ctxOffset) \ updates ctx offset and tyItem
    tyItem_refs(GET ctxTyItem) -> SET varRefs
  AGAIN l0  END_BREAK b0  END_BREAK b1
  dv_log(GET varRefs, 0xD100, 2, 0x10)

  \ Determine whether we are getting or setting
  if(scan; tokenEq(SLC_EQ)) do
       ( SG_SETTER jn GET sgMeta -> SET sgMeta; scan; single(FALSE) )
  else ( \(SG_SETTER=FALSE); tokenPlcSet(0) )

  \ Refs are easy, just apply them directly
  if(GET synRefs) do (
    dv_log(GET synRefs, 0xD102, 2, 0x10)
    assert(not (SG_SETTER msk GET sgMeta), E_cBadRefs)
    \ TODO: do "awesome compile add" if not isDirect
    assert(SG_DIRECT msk GET sgMeta, E_type)
    h1(LR) h1(GET directOffset + GET ctxOffset)
    ret;
  )
  field_szI(GET node, GET ctxTyItem) -> SET ctxSzI;
  dv_log(GET ctxSzI, 0xD103, 2, 0x10)

  \ If there is no field (only direct) just do it.
  if(not GET ctxTyItem) do (
    dv_log(GET directOffset, GET varRefs, GET synDerefs, 0xD104, 4, 0x10)
    assert(SG_DIRECT msk GET sgMeta, E_intern);
    if(not GET varRefs and isTyDict(GET node) and isDictStruct(GET node)) do (
      (GET node, GET ctxOffset)
      -> if(SG_SETTER msk GET sgMeta) do conStructOffset; else deStructOffset;
      ret;
    )
    gsDirect(GET directOffset, GET varRefs, GET synDerefs, REF ctxOffset)
    ret gsDeref(GET varRefs, GET synDerefs, REF ctxOffset)
  )

  \ We are accessing a field.
  \ note: varRefs is the number of references for the _parent_
  if(SG_DIRECT msk GET sgMeta) do (
    dv_log(GET varRefs, tyItem_refs(GET ctxTyItem), GET synDerefs, 0xD110, 4, 0x10)
    \ We have a direct node and tyItem field.
    \ Note: we use varRefs + synDerefs to check for implicit or explicit derefs.
    \  i.e. `var ctx: &CtxField; ctx.offset = 3` is an implicit deref of `&ctx`
    gsDirect(
      GET directOffset,
      GET varRefs + tyItem_refs(GET ctxTyItem),
      GET varRefs + GET synDerefs,
      REF ctxOffset)
    retIfNot(GET varRefs + GET synDerefs)
    dv_log(GET synRefs, 0xD111, 2, 0x10)
  ) else (
    dv_log(GET synRefs, 0xD120, 2, 0x10)
    assertEq(1, GET varRefs, E_intern)
  )
  GET varRefs + tyItem_refs(GET ctxTyItem) -> SET varRefs\tyRefs
  inc GET synDerefs                        -> SET synDerefs

  \ We now have a reference
  dv_log(GET varRefs, GET synDerefs, GET ctxSzI, 0xD130, 4, 0x10)
  ret gsDeref(GET varRefs\tyRefs, GET synDerefs, REF ctxOffset)
)

pub syn large fn . do ret ( notNow;
  var synRefs: U1;    countChr(0c&) -> SET synRefs;
  var synDerefs:  U1; countChr(0c@) -> SET synDerefs;
  dv_log(0x1000, 1, 0x10)
  if(GET synRefs) do assertNot(GET synDerefs, E_type);
  assert(GET synRefs < 2, E_type);

  dictRef(NULL) \ {&root}

  dv_log(dup, 0x1001, 2, 0x10)
  if(isTyLocal(dup\root)) do
    ( ret _dotLocal(\root, GET synRefs, GET synDerefs) )

  panic E_unimpl
)

\ **********
\ *   [XX].a basic dot test cases
$STORE_PRIV
fn testDotX inp(x:U1) -> out(_:U1) do ret .x
$tAssertEq(0x42, testDotX(0x42))
$tAssertEq(0x21, testDotX(0x321))

\ Create a memory location to store data.
const testU1Ref = heap; $h1(0x42); $tAssertEq(0x42, ft1(testU1Ref))

fn testDotDeref inp(x: &U1) -> out(_: U1) do ( ret .@x )
$tAssertEq(0x42, testDotDeref(testU1Ref))

fn testDotDerefSet inp(x: &U1) -> out(_: U1) do ( .@x = 0x33; ret .@x )
$tAssertEq(0x33, testDotDerefSet(testU1Ref))

\ manually store to ctx.offset then get it
large fn testDotCtx -> out(_:U2) do
  ret ( var ctx: FieldCtx; sr2(0x7788, REF ctx); .ctx.offset )
$tAssertEq(0x7788, testDotCtx;)

large fn testDotSetCtx -> out(_:U2) do
  ret ( var ctx: FieldCtx; .ctx.offset = 0x789; .ctx.offset )
$tAssertEq(0x789, testDotSetCtx;)

large fn testDotSetBoth do ret (
  var ctx: FieldCtx;
    .ctx.offset = 0x1234;  .ctx.sgMeta = 0x56;
    .ctx.szI    = 0x78;    .ctx.tyItem = 0x9ABCDEF;
  (.ctx.offset, .ctx.sgMeta, .ctx.szI, .ctx.tyItem)
)
$(testDotSetBoth;
  -> tAssertEq(0x9ABCDEF)\tyItem -> tAssertEq(0x78)\szI
  -> tAssertEq(0x56)\sgMeta      -> tAssertEq(0x1234)\offset)

\ Run a function with ctx.offset unset and ctx.tyItem = testU1Ref
large fn runCtxRef inp(largeFn: &Slot) do ret (
  var ctx: FieldCtx;  sroR:FC_tyItem(testU1Ref, REF ctx)
  dv_log(ftoR:FC_tyItem(REF ctx), 0x7100, 2, 0x10)
  xlw(REF ctx, GET largeFn)
)

large fn testCtxRef inp(ctx: &FieldCtx) -> out(_:U2) do ret (
  sr2(0x3378, GET ctx)  sroR:FC_tyItem(0x789AB, GET ctx)
  .ctx.tyItem, .ctx.offset
)
$(runCtxRef(fnRef:testCtxRef) -> tAssertEq(0x3378) -> tAssertEq(0x789AB))

large fn testCtxRefSet inp(ctx: &FieldCtx) -> out(_:U2) do ret (
  .ctx.offset = 0x1234;  .ctx.tyItem = 0x56789;
  .ctx.tyItem, .ctx.offset
)
$(runCtxRef(fnRef:testCtxRefSet) -> tAssertEq(0x1234) -> tAssertEq(0x56789))

large fn testCtxDeref inp(ctx: &FieldCtx) -> out(_:U2) do ret (
  .@ctx.tyItem
)
$sr1(0x22, testU1Ref)
$tAssertEq(0x22, runCtxRef(fnRef:testCtxDeref))

large fn testVarSet stk(v:U2) -> out(_:U2)
  do ( var v:U2 = (\v + 7);  ret .v )
$tAssertEq(0x10F7, testVarSet(0x10F0))
$STORE_PUB

\ **********
\ *   [XX].b (con|de)structuring structs

\ Recursive function to construct fields
fn _constructFields
    var(tyItem: &U1, offset:U1) \ here for bit-packing
    inp(fields: U1, ctx: &FieldCtx)
do ret (
  retIfNot .fields;
  dv_log(.ctx.offset, .ctx.tyItem, .fields, 0xC101, 4, 0x10)
  .offset = .ctx.offset;  .tyItem = .ctx.tyItem; \ cache
  .ctx.offset = bumpSz(.ctx.offset, tyItem_sz(.tyItem));
  .ctx.tyItem = tyItem_next(.tyItem);
  _constructFields(dec .fields, .ctx) \ recurse
  dv_log(tyItem_sz(.tyItem), .offset, 0xC10D, 3, 0x10)
  h1(SRLL jn szToSzI(tyItem_sz(.tyItem)));  h1(.offset); \ set the field
)

\declared large pre fn conStructOffset
    inp(node: &DNode, offset:U1)
do ret (
  assert(isTyDict(.node), 0x7114);
  dv_log(GET node, 0xCC00, 2, 0x10)
  var fields:U1 = ft1(d_tyGet(.node));
  assert(.fields < 4, E_cBadConstruct)
  var ctx: FieldCtx;
    .ctx.offset = .offset;
    .ctx.sgMeta = (SG_SETTER jn SG_DIRECT);
    .ctx.tyItem = inc d_tyGet(.node);
  dv_log(.ctx.offset, 0xCC0F, 2, 0x10)
  _constructFields(.fields, .&ctx)
)
$STORE_PRIV
fn testConStruct inp(s: Slc) -> \(...) do ret (inc .s.len, dec .s.dat)
$(testConStruct(0x12308, 0x22) -> tAssertEq(0x12307) -> tAssertEq(0x23))

large fn testConStructVar var(s: Slc) do
  (.s = (0x123456, 0x789A); ret (.s.len, .s.dat))
$(testConStructVar -> tAssertEq(0x123456) -> tAssertEq(0x789A))
$STORE_PUB

\declared large pre fn deStructOffset
    inp(node: &DNode, offset:U1)
do ret (
  assert(isTyDict(.node), 0x7114);
  var fields:U1 = ft1(d_tyGet(.node)); \ num fields
  assert(.fields < 4, E_cBadConstruct)
  var tyItem: &U1 = inc d_tyGet(.node);

  LOOP l0
    retIfNot .fields
    h1(FTLL jn szToSzI(tyItem_sz(.tyItem)));  h1(.offset); \ set the field
    .offset = bumpSz(.offset, tyItem_sz(.tyItem));
    .tyItem = tyItem_next(.tyItem);
    .fields = dec .fields;
  AGAIN l0
)
$STORE_PRIV
fn testDeStruct inp(s: Slc) -> do ret (.s -> inc\len;);
$(testDeStruct(0xABCDEF, 0x1234) -> swp;
  -> tAssertEq(0xABCDEF) -> tAssertEq(0x1235)
)
$STORE_PUB


\ TODO: still need to do:
\  - namespacing
