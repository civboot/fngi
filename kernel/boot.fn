\ TODO: see notes/ufn.md for current thoughts

\ Bootstraps the fngi language.
\ Requires: boot.sp
\
\ Note: at this stage the language is severely restricted and several
\ pieces of the language are incomplete. Any CAPITAL items like FN, IF, LOOP
\ etc do not behave in the way their lower-case counterparts will behave.
\ Refer to boot.sp for all documentation.
$fngi  $STORE_PUB

\ **********
\ * [1] Extra core functions
syn FN =  panic(E_cToken)    \ prevent hanging =
syn FN )  panic(E_cParen)    \ prevent hanging )
pub syn        FN dv      notNow; $c1(DV); jmp:h1(d_vGet(colonRef))
pub pre inline FN memSet  $h1(2) dv:DV_memSet  ret; \ [&dst v len]   "dst = v"
pub pre inline FN memCmp  $h1(2) dv:DV_memCmp  ret; \ [&a &b len -> cmp]
pub pre inline FN memMove $h1(2) dv:DV_memMove ret; \ [&dst &src len] "dst = src"
\ pub pre        FN memMove        dv:DV_memMove ret; \ [&dst &src len] "dst = src"
pub pre        FN memClr  0 swp; jmp:memSet(\a, \len)   \ [&a len] clear

$tAssert(isFnPre(dnode:memMove))  $tAssert(isFnInline(dnode:memMove))


FN ftBeN \ [addr: &U1, sz: U1 -> v]
  IF(dup\sz == 1) drp\sz; ret ftBe1(\addr); END
  IF(   \sz == 2)         ret ftBe2(\addr); END
  ret ftBe4(\addr)

FN srBeN \ [value:UN addr:&U1 sz:U1]
  IF(dup\sz == 1) drp\sz; ret srBe1(\value, \addr); END
  IF(   \sz == 2)         ret srBe2(\value, \addr); END
  ret srBe4(\value \addr)

pub pre FN dictRefMaybe \ [&root -> &node(nullable)]
  scan;  DV_comp_dGet -> dv:DV_comp; ret; 

inline pre FN >     $h1(2) swp -> (\b < \a;)  ret;     \ [a b -> a > b]
inline pre FN <=    $h1(2) swp -> (\b >= \a;) ret;     \ [a b -> a <= b]
$(tAssert(2 > 1)  tAssertNot(2 > 2)  tAssert(2 <= 2)  tAssertNot(2 <= 1))

inline pre FN le_s  $h1(2) swp -> (\b ge_s \a;)  ret;  \ [a b -> a <= b]
inline pre FN gt_s  $h1(2) swp -> (\b lt_s \a;)  ret;  \ [a b -> a >= b]
$tAssert(gt_s(neg 1, neg 2)) $tAssertNot(gt_s(neg 2, neg 2))
$tAssert(gt_s(2, neg 7))
$tAssert(le_s(neg 2, neg 2)) $tAssert(le_s(neg 3, neg 2))
$tAssert(le_s(neg 1, 100))

pre FN compNext \ [asNow]
  $declVar(declL compFn,           0, RSIZE) $declEnd
  IF(\asNow) fnRef:_now;  ELSE  fnRef:baseCompFn;  END
  dup\fnRef -> updateCompFn(\fnRef) -> SET compFn \ {fnRef}
  xlw(\fnRef);  ret(GET compFn -> SET G_compFn)

\ **********
\ * [2] Inline slices: strings and tokens
pub syn FN |  notNow; \ [-> dat len] Define a string slice
  h1(SZ1 + SLC); heap; h1(0); \ {start}
  LOOP l0  charNextEsc; \ {start, char, unknownEscape}
    IF (\unknownEscape) assert(dup\char == 0c|, E_cStr);
    ELSE IF (dup\char == 0c|)
      drp\char; (heap - ovr\start) -> dec; \ {start len}
      assert(0xFF >= ovr\len, E_cNotFit);
      swp; sr1(\len, \start); ret;
    END END  h1(\char);
  AGAIN l0
$STORE_PRIV
FN helloWorld  ret |Hello World!|  \ [-> dat len]
$tAssertEq(helloWorld, 12); \ len == 12
$tAssertEq(ft1(dup\dat), 0cH);  $tAssertEq(ft1(inc(\dat)), 0ce); \ "He"

$STORE_PUB
pub pre FN slcCmp \ [&a aLen &b bLen -> cmp]
  $declVar(declL b,    TY_VAR_INPUT, RSIZE)
  $declVar(declL bLen, TY_VAR_INPUT, RSIZE)
  $declEnd
  dv_log(dup\aLen, GET bLen, 0x333, 3, 0x10)

  IF(dup\aLen < GET bLen) drp; drp; ret(neg 1); END
  IF(   \aLen > GET bLen)      drp; ret(    1); END
  ret memCmp(\a, GET b, GET bLen)
pub pre FN slcEq  ret(slcCmp() == 0)
pub pre FN tokenEq ret(slcEq(\(...), tokenDat, tokenPlc))

$STORE_PRIV
FN helloBobby  ret |Hello Bobby!|  \ [-> dat len]
$tAssert   (slcEq(helloWorld, helloWorld))
$tAssertNot(slcEq(helloWorld, helloBobby))
$tAssertEq(slcCmp(helloWorld, helloWorld),     0) \ is equal
$tAssert(  slcCmp(helloWorld, 0, 42)      lt_s 0) \ different lengths
$tAssert(  slcCmp(helloWorld, helloBobby) gt_s 0) \ different contents

$STORE_PUB
FN SLC_DO     ret |do|
FN SLC_DOT    ret |.|
FN SLC_ELIF   ret |elif|
FN SLC_ELSE   ret |else|
FN SLC_EQUAL  ret |=|
FN SLC_PAREN  ret |(|

pre FN expectToken \ [<token/s> slc err -> &node(nullable)]
  $declVar(declL err, TY_VAR_INPUT, RSIZE)
  $declVar(declL node, 0, RSIZE)  $declEnd
  dictRefMaybe(0) -> SET node; \ {slc}
  assert(tokenEq(\slc), GET err)
  ret GET node

pre pub FN conEquals \ [`= token` asNow -> ?value]
  expectToken(SLC_EQUAL, E_needEqual) -> drp;
  ret compNext(\asNow)

pub syn FN const  \ `const token = token`
  $declVar(declL node, 0, RSIZE)  $declEnd
  notNow; dictAdd(0, 0) -> SET node;
  ret d_vSet(conEquals(TRUE), GET node)

$STORE_PRIV
const const42 = 0x42;         $tAssertEq(const42, 0x42)
const const49 = (0x42 + 7);   $tAssertEq(const49, 0x49)
$STORE_PUB

\ declDict:token(meta, value) manually declare a dictionary entry
pub syn FN declDict
  $declVar(declL node, 0, RSIZE) $declEnd
  notNow; colon; xx:dictAdd(0, 0) -> SET node;
  compNext(TRUE) -> d_vSet(\value, GET node) -> d_mSet(\meta, GET node);
  ret;

\ **********
\ * [XX] Type Scafolding and Native Type Implementation
\ Types are implemented from TY_DICT Dictionary Nodes. They have the following meta:
\
\ 11-- -CCC C=category (Native, Bitmap, Struct, etc)
\
\ The "value" in the DNode is then:
\ * MOD / SUBMOD: pointer to the root of the sub-dictionary.
\ * NATIVE: a single tyItem byte (with C=0 N=0)
\ * else: a pointer to a tyStream
\
\ A tyStream is a single byte specifying the number of tyItems, followed by
\ the tyItems (unaligned).
\
\ All tyItems start with a byte:
\    CN-- ----   C=constructed  N=named
\
\ If N=1, then the next bytes are the counted name (U1 length followed by data)
\
\ If C=0, it is not constructed, meaning it is a native type. In this case:
\    0NZZ SRRR  N=named  Z=size  R=reference depth  S=signed
\ - (Z) The sizes are the same as instructions
\ - (R) The reference depth is a count of the number of `&` in the type.
\
\ If C=1 it is constructed, the meta is:
\     1NTT -RRR
\ N=named  T=size of type reference (pointer)  R=reference depth
\
\ Then there is T size bytes of the type reference.
const TY_DICT_MSK    = 0x07;
const TY_DICT_NATIVE = 0x00;
const TY_DICT_BITMAP = 0x01;
const TY_DICT_STRUCT = 0x02;
const TY_DICT_ENUM   = 0x03;
const TY_DICT_MOD    = 0x04;
const TY_DICT_SUBMOD = 0x05;

const META_CONSTRUCTED = 0x80;
const META_NAME        = 0x40;
const META_REF_MSK     = 0x07;
const META_CONSTRUCTED_TSZ_MSK = 0x30
const META_CONSTRUCTED_TSZ_SHIFT = 4 \ TSZ needs to be shifted by 4 to get value
const META_NATIVE_SIGNED = 0x08;

declDict:U1    (TY_DICT jn TY_DICT_NATIVE,                       SZ1)
declDict:U2    (TY_DICT jn TY_DICT_NATIVE,                       SZ2)
declDict:U4    (TY_DICT jn TY_DICT_NATIVE,                       SZ4)
declDict:Slot  (TY_DICT jn TY_DICT_NATIVE,                       SZR)
declDict:I1    (TY_DICT jn TY_DICT_NATIVE, META_NATIVE_SIGNED jn SZ1)
declDict:I2    (TY_DICT jn TY_DICT_NATIVE, META_NATIVE_SIGNED jn SZ2)
declDict:I4    (TY_DICT jn TY_DICT_NATIVE, META_NATIVE_SIGNED jn SZ4)
declDict:ISlot (TY_DICT jn TY_DICT_NATIVE, META_NATIVE_SIGNED jn SZR)
$assertDictV(SZ1) U1
$assertDictV(SZR) Slot

pre FN isTyDict     ret((d_mGet(\node) msk META_TY_MASK) == TY_DICT)
pre FN isDictNative ret((d_mGet(\node) msk TY_DICT_MSK) == TY_DICT_NATIVE)
pre FN isDictStruct ret((d_mGet(\node) msk TY_DICT_MSK) == TY_DICT_STRUCT)
$tAssert(isTyDict(dnode:U1))
$tAssert(isDictNative(dnode:U1))

pre FN tySz \ {key:&DNode -> szBytes}
  assert(isTyDict(dup), E_intern)
  IF(isDictNative(dup))
    ret szIToSz(d_vGet(\key) msk SZ_MASK)
  END
  panic(E_unimpl) \ TODO: forward declaration struct sz, etc.
$tAssertEq(1,     tySz(dnode:U1))
$tAssertEq(2,     tySz(dnode:I2))
$tAssertEq(RSIZE, tySz(dnode:ISlot))

\ **********
\ * [XX] function declaration syntax (var, inp, out)

pre FN isFnAndSyn \ {&node}
  retIfNot(dup)
  IF(not isTyFn(dup)) drp; ret FALSE END
  ret isFnSyn(\node);
$tAssertNot(isFnAndSyn(dnode:isFnAndSyn))
$tAssert   (isFnAndSyn(dnode:FN))

pre FN countChr \ [chr -> numChr] and advance past them
  0\(chr, count) -> LOOP l0; 
    swp \ {count chr}
    IF(dup\chr == peekChr) swp; inc(\count); tokenPlcSet(1);
    ELSE         drp\chr; ret \count; END
  AGAIN l0
$tAssertEq(countChr(0c&) & &&, 3)   $tAssertEq(countChr(0c&) 0)

FN parseTy \ [-> numRefs &DNode]
  $declVar(declL node,    0, RSIZE) $declEnd
  countChr(0c&); ret assert(isTyDict(dictRef(0) -> dup), E_needType)
$tAssertEq(parseTy &&U1, dnode:U1)   -> $tAssertEq(\numRefs, 2)
$tAssertEq(parseTy Slot, dnode:Slot) -> $tAssertEq(\numRefs, 0)

pre FN _varImpl \ [meta]
  $declVar(declL meta, TY_VAR_INPUT, 1) $declEnd
  IF(isFnAndSyn(dictRefMaybe(0)))
    ret single(FALSE) \ next token is syn, run it (it may run us)
  END
  tokenPlcSet(0); \ make dictRefMaybe a peek
  IF(GET meta)
    declL -> colon -> parseTy; \ {&Local isLocal=1 numRefs &Type}
  ELSE
    0, 1 -> _comment -> colon -> parseTy; \ {NULL, isLocal=1, numRefs, &Type}
  END
  \ TODO: register type
  IF(swp\numRefs) drp; RSIZE
  ELSE  tySz(\type);  END \ {&Local isLocal szBytes}

  IF(GET meta)  GET meta -> swp -> declVar;
  ELSE \stk     drp; drp; drp; END
  ret;

FN _inp
  $declVar(declL compFn,  0, RSIZE)  $declEnd
  updateCompFn(fnRef:_inp) -> SET compFn;
  _varImpl($L(TY_VAR jn TY_VAR_INPUT))
  GET compFn -> SET G_compFn; ret;
pub syn FN inp
  notNow; assert(getCState(C_FN_STATE) >= FN_STATE_STK, E_fnStateInp)
  setCState(FN_STATE_INP, C_FN_STATE) \ start inp state
  keyJnMeta(GET G_curNode, TY_FN_PRE)
  _inp; ret;

$STORE_PRIV \ test inp by truncating values
pre FN testInp  inp x:U1 $declEnd  ret(GET x)
$tAssertEq(testInp(0x101), 1)

pre FN testInp3  inp (x:U1  y:U2  z: &U1)  $declEnd
  ret(GET x, GET y, GET z)
$testInp3(0x101\1, 0x12345\1000, 0x6789ABC)
$tAssertEq(0x6789ABC)  $tAssertEq(0x2345)  $tAssertEq(0x01)

$STORE_PUB
FN _var
  $declVar(declL compFn,  0, RSIZE)  $declEnd
  updateCompFn(fnRef:_var) -> SET compFn;
  _varImpl(TY_VAR);  GET compFn -> SET G_compFn; ret;
pub syn FN var  notNow;
  assert(getCState(C_FN_STATE) != FN_STATE_NO, E_fnStateVar); 
  ret _var;

FN _stk
  $declVar(declL compFn,  0, RSIZE)  $declEnd
  updateCompFn(fnRef:_stk) -> SET compFn;
  _varImpl(0);       GET compFn -> SET G_compFn; ret;
pub syn FN stk  notNow; 
  assertEq(getCState(C_FN_STATE), FN_STATE_STK, E_fnStateStk);
  keyJnMeta(GET G_curNode, TY_FN_PRE)
  ret _stk;

FN _out
  $declVar(declL compFn,  0, RSIZE)  $declEnd
  updateCompFn(fnRef:_out) -> SET compFn;
  _varImpl(0);       GET compFn -> SET G_compFn; ret;
pub syn FN out  notNow; 
  assert(getCState(C_FN_STATE) >= FN_STATE_STK, E_fnStateOut);
  setCState(FN_STATE_INP, C_FN_STATE) \ start inp state
  ret _out;

$STORE_PRIV
pre FN testVar \ x -> x + 1
  var x: U1 $declEnd  \x -> SET x; ret inc(GET x)
$tAssertEq(testVar(0x101), 2)

\ **********
\ * [3] fn
\ fn myFn stk(a:U1 b:U2) inp c:U2; var i:U2; inp d:Ref
\ -> out(x:Ref y:Ref) do (
\   var i:U2 = 7;
\   ... code
\   var j:U2 = 10;
\   ... code
\ )
$STORE_PUB

pub syn FN fn
  $declVar(declL meta,    0, RSIZE) $declEnd notNow;
  GET G_metaNext -> SET meta;
  dictRefMaybe(0) -> IF(dup\key) \ fn already exists
    assert(isFnDeclare(dup\key), E_cKey); \ {&key}
    d_vGet(dup\key) -> heap -> swp \ {&key heap &declFn}
    srBeR(\heap, \declFn) \ {&key}
  ELSE
    drp\key; tokenPlcSet(0); \ clear token
    dictAdd(0, GET G_metaNext jn TY_FN)
  END -> _FN(\key)
  IF(isMetaFnDeclare(GET meta))  srBeR(0, bump(RSIZE, FALSE))  END
  LOOP l0
    dictRefMaybe(0) \ {&Node}
    IF(tokenEq(SLC_DO)) \ function body
      drp\node; declInpEnd; scan; single(FALSE); ret declFnEnd;
    END
    assert(isFnAndSyn(\node), E_fnSyn); single(FALSE) \ compile syn fns
  AGAIN l0

$STORE_PRIV
fn testFn stk(a:Slot) inp(b:U2) do ( GET b ->  swp ->  ret; )
$(testFn(0x1234, 0x12345) -> tAssertEq(0x1234) -> tAssertEq(0x2345))

declare fn testDeclared do ()                    \ [-> U1]
fn testDeclaredUsed do ( ret testDeclared; ) \ [-> U1]
fn testDeclared do ( ret 3; )               \ [-> U1]

$tAssertEq(3, testDeclared;);
$tAssertEq(3, testDeclaredUsed;);

\ **********
\ * [4] if elif else, also $if ...
$STORE_PUB

\ cDat to Slc
fn cToSlc stk(cdat: &U1) -> out(dat: &U1, len: U2) do (
  ret (inc(dup\cdat) \(cdat, dat) -> swp -> ft1(\cdat))
)

\ TODO: I can remove recursion here and use a loop instead
fn _if do ( \ [] recursive fn of `if`
  var h: &U1  $declEnd
  scan; single(FALSE) \ compile token after `if`
  xx:IF(FALSE\asNow) -> SET h \ compile IF
  expectToken(SLC_DO, E_cToken) -> drp;
  scan; single(FALSE); \ compile token after `do`
  IF(scan; tokenEq(SLC_ELIF))
    xx:ELSE(GET h, FALSE\asNow) -> SET h;
    _if; \ recurse for next elif/else clause
  ELSE IF(tokenEq(SLC_ELSE))
    xx:ELSE(GET h, FALSE\asNow) -> SET h;
    scan; single(FALSE);
  ELSE tokenPlcSet(0); \ reset token (peeking)
  END END 
  ret _END(GET h, dup)
)

fn _ifNowLogic stk(done: Slot) -> out(a: Slot) do (
  IF(dup\done) 
    _comment; expectToken(SLC_DO, E_cToken) -> drp; 
    _comment; ret \done; END
  drp\done;  scan; single(TRUE) -> \ifChk;
  expectToken(SLC_DO, E_cToken) -> drp;
  expectToken(SLC_PAREN, E_needParen) -> drp; tokenPlcSet(0);
  IF(\ifChk) compNext(FALSE); ret TRUE; END
  _comment; ret FALSE;
)

FN _ifNow \ [] fn of `if` for the asNow case
  _ifNowLogic(FALSE) \ {done}
  LOOP l0
  IF(scan; tokenEq(SLC_ELIF))
    _ifNowLogic(\done); AGAIN l0
  ELSE IF(tokenEq(SLC_ELSE))
    IF(\done) _comment;
    ELSE      compNext(FALSE)  END
  ELSE drp\done; tokenPlcSet(0); \ reset token (peeking)
  END END ret;

syn fn if do (IF(\asNow) _ifNow; ELSE _if; END ret;)

$STORE_PRIV
fn testIf2 stk(a:Slot) -> out(b:Slot) do ( \ converts 1->4, 2->7, else: 13
  if(dup == 1)  do (drp; ret 4)
  elif(\a == 2) do (     ret 7)
  ret (0x99)
)
$tAssertEq(testIf2(1), 4)      $tAssertEq(testIf2(2), 7)
$tAssertEq(testIf2(12), 0x99)  $assertNoWs

fn testManyElif inp(a:Slot) -> out(b:Slot) do ( \ [a -> b] ...
  if   (GET a < 0x10) do ret(0x1000 + GET a)
  elif (GET a < 0x20) do ret(0x2000 + GET a)
  elif (GET a < 0x30) do ret(0x3000 + GET a)
  elif (GET a < 0x40) do    (0x4000 + GET a) \ note: fallthrough
  else ret(0x10 + GET a);
  ret inc(\fallthrough);
)
$tAssertEq(testManyElif(0x5),  0x1005)  $tAssertEq(testManyElif(0x17), 0x2017)
$tAssertEq(testManyElif(0x22), 0x3022)  $tAssertEq(testManyElif(0x33), 0x4034)
$tAssertEq(testManyElif(0x55), 0x65)

$assertNoWs
$if(1) do ($0x42)           -> $tAssertEq(0x42)
$if(1) do ($0x42) else ($7) -> $tAssertEq(0x42)
$if 0  do ($0x42) else ($7) -> $tAssertEq(7)

$tAssertEq(if(1) do ($42) else ($3), 42)

$if 0 do ($0x42) elif(0) do ($3) elif(1) do ($0x44) else ($0x77)
$tAssertEq(0x44)

fn testIfNow do (ret($if(0) do (4) else (0x3F + 3)))  $assertNoWs
$tAssertEq(testIfNow, 0x42)


\ **********
\ * [5] struct
\ Structs are a dict node with a value to a root node, and type to a tyStream
\ of the struct fields. The byte structure is:
\
\   numFields:U1 | ... fields
\
\ struct Foo (
\   a: U2,
\   b: &U1,
\ )

\ **********
\ *   [5.a] utilities
$STORE_PUB
const LOC_LOCAL = 0;
const LOC_PRIV  = 1;
const LOC_PUB   = 2;

fn locBBA stk(l:U1) do ( \ -> out(_:&BBA)
  if(dup\l == LOC_LOCAL) do (drp; ret REF G_bbaLocal)
  elif(\l == LOC_PRIV  ) do (     ret GET G_bbaPriv)
  ret GET G_bbaPub;
)

fn nameLoc -> out(loc:U1) do ( \ where location names are stored
  if(C_LOCAL    msk GET G_cstate) do ret LOC_LOCAL
  if(C_PUB_NAME msk GET G_cstate) do ret LOC_PUB else ret LOC_PRIV;
)

fn bumpName stk(size:U2, aligned:U1) -> out(_: &U1) do (
  ret BBA_bump(\size, \aligned, locBBA(nameLoc));
)


\ **********
\ *   [5.a] struct declaration
pre fn needSzI do ( \ (value -> neededSzI)
  IF(dup\value < 0x100  ) drp; ret SZ1; END
  IF(   \value <= 0xFFFF)      ret SZ2; END
                               ret SZ4;
)
$tAssertEq(SZ1, needSzI(0))      $tAssertEq(SZ1, needSzI(1))
$tAssertEq(SZ2, needSzI(0x100))  $tAssertEq(SZ2, needSzI(0xFFFF))
$tAssertEq(SZ4, needSzI(0x10000))

pre fn _constructedMeta stk(numRefs:U1) inp(key:Slot) -> out(m:U1) do (
  \numRefs
  jn META_CONSTRUCTED
  jn (szIToSz(needSzI(GET key)) shl META_CONSTRUCTED_TSZ_SHIFT) \ TSZ
  -> ret;
)

\ Store current token to name memory
fn storeToken -> out(cname: &U1) do (
  bumpName(tokenPlc + 1, FALSE) \ {&cDat}
  memMove(inc(dup;\cDat), tokenDat, tokenPlc) \ {&cDat}
  sr1(tokenPlc, ovr\cDat)
  ret \cDat;
)

$STORE_PRIV
fn testStoreToken do (
  scan; storeToken -> tAssertEq(ft1(dup\name), 7)
  ret tAssert(slcEq(cToSlc(\name), |testing|))
)
$testStoreToken testing

$STORE_PUB

\ Compile a struct field, which may be a block of fields.
large fn _field do (
  var compFn: &Slot; updateCompFn(fnRef:_field) -> SET compFn;
  IF(isFnAndSyn(dictRefMaybe(0)))
    single(FALSE) \ next token is syn, run it (it may run us)
  ELSE
    var ref: &U1; d_vGet(GET G_curNode) -> SET ref;
    sr1(inc ft1(GET ref), GET ref) \ struct.ty.numFields += 1
    \ Reserve then move cfield name
    bumpName(1, FALSE) -> SET ref; bumpName(tokenPlc + 1, FALSE) \ {&cname}
    memMove(inc(\cname), tokenDat, tokenPlc); \ move cfield name
    sr1(tokenPlc, inc GET ref);               \ set cfield count
    colon; var tyNode: &Slot; parseTy -> SET tyNode; \ {numRefs}

    \ store the tyItem meta, then the tyNode reference
    sr1(_constructedMeta(\numRefs, GET tyNode) jn META_NAME, GET ref)
    GET tyNode -> needSzI(GET tyNode) -> bumpName(szIToSz(dup\szI), FALSE)
    -> swp -> srBeSzI(\tyNode, \(&tyNode), \szI)
  END
  GET compFn -> SET G_compFn; ret;
)

\ large syn fn struct do (  notNow;
\   dictAdd(NULL, $L(C_TYPED jn TY_DICT jn TY_DICT_STRUCT)) -> SET G_curNode;
\   var ty: &U1; bumpName(1, FALSE\aligned) -> SET ty;
\   d_vSet(GET ty, GET G_curNode);
\   sr1(0\numFields, GET ty);
\   _field;
\   ret;
\ )
\ 
\ pub struct DNode (
\   l: &DNode;
\   r: &DNode;
\   ckey: &U1;  v: Slot;    m: U2;
\ )
\ 
\ fn isTyped stk(n: &DNode) -> out(_:U1) do ret(d_mGet(\n) msk C_TYPED)
\ fn isTyStruct stk(node: &DNode) -> out(_:U1) do (
\   isTyDict(dup\node) -> swp -> isDictStruct(\node) -> and -> ret;
\ )
\ $tAssertNot(isTyStruct(dnode:U1))
\ $tAssert   (isTyStruct(dnode:DNode))
\ 
\ \ **********
\ \ *   [5.b] Working with a tystream
\ 
\ \ Return reference to the data (either ref or native byte)
\ fn tyItem_dat stk(ty: &U1) -> out(dat: &U1) do (
\   if(ft1(dup\ty) msk META_NAME) do ( \ skip name
\     ret (dup\ty + inc2 ft1(inc\ty;)) \ ty + nameCount+2
\   ) ret inc\ty;
\ )

\ \ Return the dictionary node for the tyItem
\ fn tyItem_node stk(ty: &U1) -> out(node: &DNode) do (
\   ft1(dup) \ tyMeta
\   assert(dup\tyMeta msk META_CONSTRUCTED, E_intern);
\   dup\tyMeta msk META_TSZ_MSK shr META_TSZ_SHIFT \ {ty tsz}
\   ret(swp -> tyItem_dat(\ty) -> swp -> jmp:ftBeN(\tdat, \tsz))
\ )


\ $STORE_PRIV
\ 
\ $tAssert(isTyStruct(dnode:DNode));
\ $tAssertNot(ft1(d_tyGet(dnode:U1)) msk META_CONSTRUCTED)
\ $tAssert(ft1(d_tyGet(dnode:DNode)) msk META_CONSTRUCTED)
\ \ $testStruct;
\ 
\ $STORE_PUB
