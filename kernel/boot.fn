\ TODO: see notes/ufn.md for current thoughts

\ Bootstraps the fngi language.
\ Requires: boot.sp
\
\ Note: at this stage the language is severely restricted and several
\ pieces of the language are incomplete. Any CAPITAL items like FN, IF, LOOP
\ etc do not behave in the way their lower-case counterparts will behave.
\ Refer to boot.sp for all documentation.
$fngi  $STORE_PUB

\ **********
\ * [1] Extra core functions
pub syn        FN dv      notNow; $c1(DV); jmp:h1(d_vGet(colonRef))
pub pre inline FN memSet  $h1(2) dv:DV_memSet  ret; \ [&dst v len]   "dst = v"
pub pre inline FN memCmp  $h1(2) dv:DV_memCmp  ret; \ [&dst &src len] "dst = src"
pub pre inline FN memMove $h1(2) dv:DV_memMove ret; \ [&a &b len -> cmp]
pub pre        FN memClr  0 swp; jmp:memSet(_, _)   \ [&a len] clear

pub pre FN dictRefMaybe \ [&root -> &node(nullable)]
  scan;  DV_comp_dGet -> dv:DV_comp; ret; 

syn FN =  panic(E_cToken)    \ prevent hanging =
syn FN )  panic(E_cParen)    \ prevent hanging )

inline pre FN >     $h1(2) swp -> (_ < _)  ret;     \ [a b -> a > b]
inline pre FN <=    $h1(2) swp -> (_ >= _) ret;     \ [a b -> a <= b]
$tAssert(2 > 1) $tAssertNot(2 > 2) $tAssert(2 <= 2) $tAssertNot(2 <= 1)

inline pre FN le_s  $h1(2) swp -> (_ ge_s _)  ret;  \ [a b -> a <= b]
inline pre FN gt_s  $h1(2) swp -> (_ lt_s _)  ret;  \ [a b -> a >= b]
$tAssert(gt_s(neg 1, neg 2)) $tAssertNot(gt_s(neg 2, neg 2))
$tAssert(gt_s(2, neg 7))
$tAssert(le_s(neg 2, neg 2)) $tAssert(le_s(neg 3, neg 2))
$tAssert(le_s(neg 1, 100))

pre FN compNext \ [asNow]
  $declVar(declL compFn,           0, RSIZE) $declEnd
  IF(\asNow) fnRef:_now;  ELSE  fnRef:baseCompFn;  END
  dup\fnRef -> updateCompFn(\fnRef) -> SET compFn \ {fnRef}
  xlw(\fnRef);  ret(GET compFn -> SET G_compFn)

\ **********
\ * [2] Inline slices: strings and tokens
pub syn FN |  notNow; \ [-> dat len] Define a string slice
  h1(SZ1 + SLC); heap; h1(0); \ {start}
  LOOP l0  charNextEsc; \ {start, char, unknownEscape
    \ IF (\unknownEscape) assert(dup\char == 0c|, E_cStr);
    IF (\unknownEscape) assert(dup\char == 0c|, E_cStr);
    ELSE IF (dup\char == 0c|)
      drp\char; (heap - ovr\start) -> dec; \ {start len}
      assert(0xFF >= ovr\len, E_cNotFit);
      swp; sr1(\len, \start); ret;
    END END  h1(\char);
  AGAIN l0
$STORE_PRIV
FN helloWorld  ret |Hello World!|  \ [-> dat len]
$tAssertEq(helloWorld, 12); \ len == 12
$tAssertEq(ft1(dup\dat), 0cH);  $tAssertEq(ft1(inc(\dat)), 0ce); \ "He"

$STORE_PUB
pub pre FN slcCmp \ [&a aLen &b bLen -> cmp]
  $declVar(declL b,    TY_VAR_INPUT, RSIZE)
  $declVar(declL bLen, TY_VAR_INPUT, RSIZE)
  $declEnd
  IF(dup\aLen < GET bLen) drp; drp; ret(neg 1); END
  IF(   \aLen > GET bLen)      drp; ret(    1); END
  ret memCmp(\a, GET b, GET bLen)
pub pre FN slcEq  ret(slcCmp(_) == 0)
pub pre FN tokenEq ret(slcEq(_, tokenDat, tokenPlc))

$STORE_PRIV
FN helloBobby  ret |Hello Bobby!|  \ [-> dat len]
$tAssert   (slcEq(helloWorld, helloWorld))
$tAssertNot(slcEq(helloWorld, helloBobby))
$tAssertEq(slcCmp(helloWorld, helloWorld),     0) \ is equal
$tAssert(  slcCmp(helloWorld, 0, 42)      lt_s 0) \ different lengths
$tAssert(  slcCmp(helloWorld, helloBobby) gt_s 0) \ different contents

$STORE_PUB
FN SLC_EQUAL  ret |=|
FN SLC_DO     ret |do|
FN SLC_ELIF   ret |elif|
FN SLC_ELSE   ret |else|
FN SLC_PAREN  ret |(|

pre FN expectToken \ [<token/s> slc err -> &node(nullable)]
  $declVar(declL err, TY_VAR_INPUT, RSIZE)
  $declVar(declL node, 0, RSIZE)  $declEnd
  dictRefMaybe(0) -> SET node; \ {slc}
  assert(tokenEq(\slc), GET err)
  ret GET node

pre pub FN equals \ [`= token` asNow -> ?value]
  expectToken(SLC_EQUAL, E_needEqual) -> drp;
  ret compNext(\asNow)

pub syn FN const  \ `const token = token`
  $declVar(declL node, 0, RSIZE)  $declEnd
  notNow; dictAdd(0, 0) -> SET node;
  ret d_vSet(equals(TRUE), GET node)

$STORE_PRIV
const const42 = 0x42;         $tAssertEq(const42, 0x42)
const const49 = (0x42 + 7);   $tAssertEq(const49, 0x49)
$STORE_PUB

\ **********
\ * [XX] type stuff
\ TODO: move to code dump?

\ SlcNode struct
const SN_left = 0;                 \ &SlcNode: .left
const SN_right = RSIZE;            \ &SlcNode: .right
const SN_dat = (SN_right + RSIZE); \ Ref:      .key.dat
const SN_len = (SN_dat + RSIZE);   \ U2:       .key.len

\ Find slice in BST, starting at node. Set result to node.
\ returns 0 if node==NULL
\ The return value is the result of `slcCmp(node.key, out.key)`
pre FN SN_find
  $declVar(declL node,   TY_VAR_INPUT, RSIZE) \ &&SlcNode
  $declVar(declL slcDat, TY_VAR_INPUT, RSIZE) \ slc.dat
  $declVar(declL slcLen, TY_VAR_INPUT, 2)     \ slc.len
  $declVar(declL cmp, 0, RSIZE)
  $declEnd
  IF(not ftoR:0(GET node)) ret 0; END \ if (&SlcNode == NULL) ret 0
  LOOP l0
    slcCmp(ftoR:SN_dat(GET node), fto2:SN_len(GET node),
           GET slcDat,            GET slcLen) -> SET cmp;
    IF(not GET cmp) ret 0; END \ found exact match
    IF(GET cmp < 0)
      ftoR:SN_left(ftR(GET node)) \ node.left
      IF(dup) srR(\(node.left), GET node)
      ELSE    drp; ret GET cmp;  END
    ELSE \ cmp > 0
      ftoR:SN_right(ftR(GET node)) \ node.right
      IF(dup) srR(\(node.right), GET node)
      ELSE    drp; ret GET cmp;  END
    END
  AGAIN l0

\ **********
\ * [3] if .. elif ... else
\ We define both if and $if

\ TODO: I can remove recursion here and use a loop instead
FN _if \ [] recursive fn of `if`
  $declVar(declL h,    0, RSIZE) $declEnd
  scan; single(FALSE) \ compile token after `if`
  xx:IF(FALSE\asNow) -> SET h \ compile IF
  expectToken(SLC_DO, E_cToken) -> drp;
  scan; single(FALSE); \ compile token after `do`
  IF(scan; tokenEq(SLC_ELIF))
    xx:ELSE(GET h, FALSE\asNow) -> SET h;
    _if; \ recurse for next elif/else clause
  ELSE IF(tokenEq(SLC_ELSE))
    xx:ELSE(GET h, FALSE\asNow) -> SET h;
    scan; single(FALSE);
  ELSE tokenPlcSet(0); \ reset token (peeking)
  END END 
  ret _END(GET h, dup)

pre FN _ifNowLogic \ [done -> done]
  IF(dup\done) 
    _comment; expectToken(SLC_DO, E_cToken) -> drp; 
    _comment; ret _\done; END
  drp\done;  scan; single(TRUE) -> \ifChk;
  expectToken(SLC_DO, E_cToken) -> drp;
  expectToken(SLC_PAREN, E_needParen) -> drp; tokenPlcSet(0);
  IF(\ifChk) compNext(FALSE); ret TRUE; END
  _comment; ret FALSE;

FN _ifNow \ [] fn of `if` for the asNow case
  _ifNowLogic(FALSE) \ {done}
  LOOP l0
  IF(scan; tokenEq(SLC_ELIF))
    _ifNowLogic(_\done); AGAIN l0
  ELSE IF(tokenEq(SLC_ELSE))
    IF(\done) _comment;
    ELSE      compNext(FALSE)  END
  ELSE drp\done; tokenPlcSet(0); \ reset token (peeking)
  END END ret;

syn FN if  IF(\asNow) _ifNow; ELSE _if; END ret;

$STORE_PRIV
pre FN testIf2 \ [a -> b] converts 1->4, 2->7, else: 13
  if(dup == 1)  do (drp; ret 4)
  elif(\a == 2) do (     ret 7)
  ret (0x99)
$tAssertEq(testIf2(1), 4)      $tAssertEq(testIf2(2), 7)
$tAssertEq(testIf2(12), 0x99)  $assertNoWs

pre FN testManyElif \ [a -> b]
  $declVar(declL a,    TY_VAR_INPUT, RSIZE) $declEnd
  if   (GET a < 0x10) do ret(0x1000 + GET a)
  elif (GET a < 0x20) do ret(0x2000 + GET a)
  elif (GET a < 0x30) do ret(0x3000 + GET a)
  elif (GET a < 0x40) do    (0x4000 + GET a) \ note: fallthrough
  else ret(0x10 + GET a)
  ret inc(_)
$tAssertEq(testManyElif(0x5),  0x1005)  $tAssertEq(testManyElif(0x17), 0x2017)
$tAssertEq(testManyElif(0x22), 0x3022)  $tAssertEq(testManyElif(0x33), 0x4034)
$tAssertEq(testManyElif(0x55), 0x65)

$assertNoWs
$if(1) do ($0x42)
$tAssertEq(_, 0x42)
$if(1) do ($0x42) else ($7)    $tAssertEq(_, 0x42)
$if 0  do ($0x42) else ($7)    $tAssertEq(_, 7)

$tAssertEq(if(1) do ($42) else ($3), 42)

$if 0 do ($0x42) elif(0) do ($3) elif(1) do ($0x44) else ($0x77)
$tAssertEq(_, 0x44)

FN testIfNow ret($if(0) do (4) else (0x3F + 3))  $assertNoWs
$tAssertEq(testIfNow, 0x42)

\ **********
\ * [4] fn
\ fn myFn stk(a:U1 b:U2) inp c:U2; var i:U2; inp d:Ref
\ -> out(x:Ref y:Ref) do (
\   var i:U2 = 7;
\   ... code
\   var j:U2 = 10;
\   ... code
\ )

$assertNoWs
