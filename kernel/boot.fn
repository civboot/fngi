\ TODO: see notes/ufn.md for current thoughts

\ Bootstraps the fngi language.
\ Requires: boot.sp
\
\ Note: at this stage the language is severely restricted and several
\ pieces of the language are incomplete. Any CAPITAL items like FN, IF, LOOP
\ etc do not behave in the way their lower-case counterparts will behave.
\ Refer to boot.sp for all documentation.
\
\ DEVELOPER NOTES
\ Debug tooling at this stage is _extremely_ limited:
\   dv_log(val1, val2, identifier, 3\wsLen, 0x10) -> log some hex values to user
\   $setLogLvlSys(LOG_EXECUTE)                    -> log all calls
\   $setLogLvlSys(LOG_INSTR)                      -> log all instrs
$fngi  $STORE_PUB

\ **********
\ * [1] Extra core functions
syn FN =  panic(E_cToken)    \ prevent hanging =
syn FN )  panic(E_cParen)    \ prevent hanging )
pub syn        FN dv      notNow; $c1(DV); jmp:h1(d_vGet(colonRef))
pub pre inline FN memSet  $h1(2) dv:DV_memSet  ret; \ [&dst v len]   "dst = v"
pub pre inline FN memCmp  $h1(2) dv:DV_memCmp  ret; \ [&a &b len -> cmp]
pub pre inline FN memMove $h1(2) dv:DV_memMove ret; \ [&dst &src len] "dst = src"
\ pub pre        FN memMove        dv:DV_memMove ret; \ [&dst &src len] "dst = src"
pub pre        FN memClr 0 -> swp -> ret memSet(\a, \0, \len); \ [&a len] clear

$tAssert(isFnPre(dnode:memMove))  $tAssert(isFnInline(dnode:memMove))

pub pre FN dictRefMaybe \ [&root -> &node(nullable)]
  scan;  DV_comp_dGet -> dv:DV_comp; ret;

inline pre FN >     $h1(2) swp -> (\b < \a;)  ret;     \ [a b -> a > b]
inline pre FN <=    $h1(2) swp -> (\b >= \a;) ret;     \ [a b -> a <= b]
$(tAssert(2 > 1)  tAssertNot(2 > 2)  tAssert(2 <= 2)  tAssertNot(2 <= 1))

inline pre FN le_s  $h1(2) swp -> (\b ge_s \a;)  ret;  \ [a b -> a <= b]
inline pre FN gt_s  $h1(2) swp -> (\b lt_s \a;)  ret;  \ [a b -> a >= b]
$tAssert(gt_s(neg 1, neg 2)) $tAssertNot(gt_s(neg 2, neg 2))
$tAssert(gt_s(2, neg 7))
$tAssert(le_s(neg 2, neg 2)) $tAssert(le_s(neg 3, neg 2))
$tAssert(le_s(neg 1, 100))

pre FN compNext \ [asNow]
  $declVar(declL compFn,           0, RSIZE) $declEnd
  IF(\asNow) fnRef:_now;  ELSE  fnRef:baseCompFn;  END
  dup\fnRef -> updateCompFn(\fnRef) -> SET compFn \ {fnRef}
  xlw(\fnRef);  ret(GET compFn -> SET G_compFn)

\ **********
\ * [2] Inline slices: strings and tokens
pub syn FN |  notNow; \ [-> dat len] Define a string slice
  h1(SZ1 + SLC); heap; h1(0); \ {start}
  LOOP l0  charNextEsc; \ {start, char, unknownEscape}
    IF (\unknownEscape) assert(dup\char == 0c|, E_cStr);
    ELSE IF (dup\char == 0c|)
      drp\char; (heap - ovr\start) -> dec; \ {start len}
      assert(0xFF >= ovr\len, E_cNotFit);
      swp; sr1(\len, \start); ret;
    END END  h1(\char);
  AGAIN l0
$STORE_PRIV
FN helloWorld  ret |Hello World!|  \ [-> dat len]
$tAssertEq(helloWorld, 12); \ len == 12
$tAssertEq(ft1(dup\dat), 0cH);  $tAssertEq(ft1(inc(\dat)), 0ce); \ "He"

$STORE_PUB
pub pre FN slcCmp \ [&a aLen &b bLen -> cmp]
  $declVar(declL b,    TY_VAR_INPUT, RSIZE)
  $declVar(declL bLen, TY_VAR_INPUT, RSIZE)
  $declEnd
  IF(dup\aLen < GET bLen) drp; drp; ret(neg 1); END
  IF(   \aLen > GET bLen)      drp; ret(    1); END
  ret memCmp(\a, GET b, GET bLen)
pub pre FN slcEq  ret(slcCmp() == 0)
pub pre FN tokenEq ret(slcEq(\(...), tokenDat, tokenPlc))

$STORE_PRIV
FN helloBobby  ret |Hello Bobby!|  \ [-> dat len]
$tAssert   (slcEq(helloWorld, helloWorld))
$tAssertNot(slcEq(helloWorld, helloBobby))
$tAssertEq(slcCmp(helloWorld, helloWorld),     0) \ is equal
$tAssert(  slcCmp(helloWorld, 0, 42)      lt_s 0) \ different lengths
$tAssert(  slcCmp(helloWorld, helloBobby) gt_s 0) \ different contents

$STORE_PUB
FN SLC_DO     ret |do|
FN SLC_DOT    ret |.|
FN SLC_ELIF   ret |elif|
FN SLC_ELSE   ret |else|
FN SLC_EQUAL  ret |=|
FN SLC_PAREN  ret |(|
FN SLC_BRACK_O ret |[|
FN SLC_BRACK_C ret |]|

pre FN expectToken \ [<token/s> slc err -> &node(nullable)]
  $declVar(declL err, TY_VAR_INPUT, RSIZE)
  $declVar(declL node, 0, RSIZE)  $declEnd
  dictRefMaybe(0) -> SET node; \ {slc}
  assert(tokenEq(\slc), GET err)
  ret GET node

pre pub FN conEquals \ [`= token` asNow -> ?value]
  expectToken(SLC_EQUAL, E_needEqual) -> drp;
  ret compNext(\asNow)

pub syn FN const  \ `const token = token`
  $declVar(declL node, 0, RSIZE)  $declEnd
  notNow; dictAdd(0, 0) -> SET node;
  ret d_vSet(conEquals(TRUE), GET node)

$STORE_PRIV
const const42 = 0x42;         $tAssertEq(const42, 0x42)
const const49 = (0x42 + 7);   $tAssertEq(const49, 0x49)
$STORE_PUB

pre FN isTyped      ret( d_mGet(\node) msk C_TYPED )
pre FN d_tyGet \ {&DNode -> ty}
  assert(isTyped(dup\dnode), E_intern) -> ret ftoR:DN_ty;

pre FN d_tySet \ {&ty &DNode}
  assert(isTyped(dup\dnode), E_intern) -> ret sroR:DN_ty;

\ declTy:token(meta, ty) manually declare a dictionary entry
pub syn FN declTy ret (
  $declVar(declL node, 0, RSIZE) $declEnd
  notNow; colon; xx:dictAdd(0\v, C_TYPED\m) -> SET node;
  compNext(TRUE) -> swp -> d_mSet(\meta, GET node) -> d_tySet(\ty, GET node);
)

\ **********
\ * [XX] Type Scafolding and Native Type Implementation
\ Types are implemented from TY_DICT Dictionary Nodes, with meta:
\
\ 11-- -CCC C=category (Native, Bitmap, Struct, etc)
\
\ They also have C_TYPED set, which means they have a "ty" value:
\ * MOD / SUBMOD: C_TYPED must be 0. Value is the pointer to the sub-dictionary.
\ * NATIVE: a single tyItem byte (with C=0 N=0)
\ * else: a pointer to a tyStream
\
\ A tyStream starts with a single byte specifying the number of tyItems,
\ followed by tyItem elements (unaligned):
\    CN-- ----   C=constructed  N=named   \ first tyItem byte
\
\ If N=1, then the next bytes are the counted name (U1 length followed by data)
\
\ If C=0, it is not constructed, meaning it is a native type. In this case
\ the byte is:
\    0NZZ SRRR  N=named  Z=size  R=reference depth  S=signed
\ - (Z) The sizes are the same as instructions
\ - (R) The reference depth is a count of the number of `&` in the type.
\
\ If C=1 it is constructed, the meta is:
\     1NTT -RRR
\ N=named  T=SzI of type reference (pointer)  R=reference depth
\
\ Then there is T size bytes of the type reference.
const TY_DICT_MSK    = 0x07;
const TY_DICT_NATIVE = 0x00;
const TY_DICT_BITMAP = 0x01;
const TY_DICT_STRUCT = 0x02;
const TY_DICT_ENUM   = 0x03;
const TY_DICT_MOD    = 0x04;
const TY_DICT_SUBMOD = 0x05;

const META_CONSTRUCTED   = 0x80;
const META_NAMED         = 0x40;
const META_REF_MSK       = 0x07;
const META_NATIVE_SIGNED = 0x08;
const _native = (C_TYPED jn TY_DICT jn TY_DICT_NATIVE)

declTy:U1    (_native,                       SZ1)
declTy:U2    (_native,                       SZ2)
declTy:U4    (_native,                       SZ4)
declTy:Slot  (_native,                       SZR)
declTy:I1    (_native, META_NATIVE_SIGNED jn SZ1)
declTy:I2    (_native, META_NATIVE_SIGNED jn SZ2)
declTy:I4    (_native, META_NATIVE_SIGNED jn SZ4)
declTy:ISlot (_native, META_NATIVE_SIGNED jn SZR)

pre FN isTyDict     ret((d_mGet(\node) msk META_TY_MASK) == TY_DICT      )
pre FN isDictNative ret((d_mGet(\node) msk TY_DICT_MSK) == TY_DICT_NATIVE)
pre FN isDictStruct ret((d_mGet(\node) msk TY_DICT_MSK) == TY_DICT_STRUCT)
$tAssert(isTyDict(dnode:U1))
$tAssert(isDictNative(dnode:U1))

\ **********
\ * [XX] fn
\ fn myFn stk(a:U1 b:U2) inp c:U2; var i:U2; inp d:Ref
\ -> out(x:Ref y:Ref) do (
\   var i:U2 = 7;
\   ... code
\   var j:U2 = 10;
\   ... code
\ )
$STORE_PUB

pre FN isFnAndSyn \ {&node}
  retIfNot(dup)
  IF(not isTyFn(dup)) drp; ret FALSE END
  ret isFnSyn(\node);
$tAssertNot(isFnAndSyn(dnode:isFnAndSyn))
$tAssert   (isFnAndSyn(dnode:FN))

pub syn FN fn
  $declVar(declL meta,    0, RSIZE) $declEnd notNow;
  GET G_metaNext -> SET meta;
  dictRefMaybe(0) -> IF(dup\key) \ fn already exists
    assert(isFnDeclare(dup\key), E_cKey); \ {&key}
    d_vGet(dup\key) -> heap -> swp \ {&key heap &declFn}
    srBeR(\heap, \declFn) \ {&key}
  ELSE
    drp\key; tokenPlcSet(0); \ clear token
    dictAdd(0, GET G_metaNext jn TY_FN)
  END -> _FN(\key)
  IF(isMetaFnDeclare(GET meta))  srBeR(0, bump(RSIZE, FALSE))  END
  LOOP l0
    dictRefMaybe(0) \ {&Node}
    IF(tokenEq(SLC_DO)) \ function body
      drp\node; declInpEnd; scan; single(FALSE);
      ret declFnEnd;
    END
    assert(isFnAndSyn(\node), E_fnSyn); single(FALSE) \ compile syn fns
  AGAIN l0

$STORE_PRIV
pre fn testFn \(a:Slot b:U2 -> b a) do ( swp -> ret; )
$(testFn(0x4321, 0x54321) -> tAssertEq(0x4321) -> tAssertEq(0x54321))

declare fn testDeclared do ()                    \ [-> U1]
fn testDeclaredUsed do ( ret testDeclared; ) \ [-> U1]
fn testDeclared do ( ret 3; )               \ [-> U1]

$STORE_PUB
\ **********
\ * [XX] function declaration syntax (var, inp, out)
declare large pre fn struct_sz \(s: &DNode -> sz:U2) do;

pre FN tySz \ {node:&DNode -> szBytes}
  assert(isTyDict(dup), 0xB001\E_intern)
  IF(isDictNative(dup)) ret szIToSz(d_tyGet(\node) msk SZ_MASK) END
  IF(isDictStruct(dup)) ret struct_sz(\node)                   END
  panic(E_unimpl) \ TODO: other types
$tAssertEq(1,     tySz(dnode:U1))
$tAssertEq(2,     tySz(dnode:I2))
$tAssertEq(RSIZE, tySz(dnode:ISlot))

pre FN countChr \ [chr -> numChr] and advance past them
  0\(chr, count) -> LOOP l0;
    swp \ {count chr}
    IF(dup\chr == peekChr) swp; inc(\count); tokenPlcSet(1);
    ELSE         drp\chr; ret \count; END
  AGAIN l0
$tAssertEq(countChr(0c&) & &&, 3)   $tAssertEq(countChr(0c&) 0)

FN parseTy \ [-> numRefs &DNode]
  $declVar(declL node,    0, RSIZE) $declEnd
  countChr(0c&); ret assert(isTyDict(dictRef(0) -> dup), E_needType)
$tAssertEq(parseTy &&U1, dnode:U1)   -> $tAssertEq(\numRefs, 2)
$tAssertEq(parseTy Slot, dnode:Slot) -> $tAssertEq(\numRefs, 0)

pre FN _varImpl \ [meta]
  $declVar(declL meta, TY_VAR_INPUT, 2)
  $declVar(declL node,            0, RSIZE) $declEnd
  IF(isFnAndSyn(dictRefMaybe(0)))
    ret single(FALSE) \ next token is syn, run it (it may run us)
  END
  tokenPlcSet(0); \ make dictRefMaybe a peek
  dv_log(0x900, 1, 0x10)
  IF(GET meta) \ a "real" variable. Parse ty and update dnode's meta and ty
    (GET meta jn C_TYPED jn C_LOCAL) -> SET meta \ ensure meta is C_TYPED
    ldictAdd(0\value, GET meta) -> SET node
    assertEq(GET meta, d_mGet(GET node), E_intern)
    GET node, 1\isLocal -> colon -> parseTy; \ {&Local isLocal=1 numRefs &Type}
    -> d_tySet(dup\type, GET node)
    -> assert(ovr\numRefs < 4, E_cBadRefs)
    -> ovr\numRefs jn GET meta -> SET meta   \ {&Local isLocal=1 numRefs &Type}
  ELSE \ a "fake" variable (i.e. `stk`)
    0, 1 -> _comment -> colon -> parseTy;    \ {NULL, isLocal=1, numRefs, &Type}
  END
  dv_log(0x910, 1, 0x10)
  \ TODO: register type
  IF(swp\numRefs) drp; RSIZE
  ELSE            tySz(\type);  END \ {&Local isLocal szBytes}

  dv_log(0x920, 1, 0x10)
  IF(GET meta)
    dv_log(0x921, 1, 0x10)
    GET meta -> swp -> declVar;
  ELSE \stk
    drp; drp; drp;
  END
  dv_log(0x930, 1, 0x10)
  ret;

FN _inp
  $declVar(declL compFn,  0, RSIZE)  $declEnd
  updateCompFn(fnRef:_inp) -> SET compFn;
  _varImpl($L(TY_VAR jn TY_VAR_INPUT))
  GET compFn -> SET G_compFn; ret;
pub syn FN inp
  notNow; assert(getCState(C_FN_STATE) >= FN_STATE_STK, E_fnStateInp)
  setCState(FN_STATE_INP, C_FN_STATE) \ start inp state
  keyJnMeta(GET G_curNode, TY_FN_PRE)
  _inp; ret;

$STORE_PRIV
\ test inp by truncating values
pre FN testInp  inp x:U1 $declEnd  ret(GET x)
$tAssertEq(testInp(0x101), 1)

pre FN testInp3  inp (x:U1  y:U2  z: &U1)  $declEnd
  ret(GET x, GET y, GET z)
$testInp3(0x101\U1, 0x12345\U2, 0x6789ABC\reference)
$tAssertEq(0x6789ABC)  $tAssertEq(0x2345)  $tAssertEq(0x01)

$STORE_PUB
FN _var
  $declVar(declL compFn,  0, RSIZE)  $declEnd
  updateCompFn(fnRef:_var) -> SET compFn;
  _varImpl(TY_VAR);  GET compFn -> SET G_compFn; ret;
pub syn FN var  notNow;
  assert(getCState(C_FN_STATE) != FN_STATE_NO, E_fnStateVar); 
  ret _var;

FN _stk
  $declVar(declL compFn,  0, RSIZE)  $declEnd
  updateCompFn(fnRef:_stk) -> SET compFn;
  _varImpl(0);       GET compFn -> SET G_compFn; ret;
pub syn FN stk  notNow; 
  assertEq(getCState(C_FN_STATE), FN_STATE_STK, E_fnStateStk);
  keyJnMeta(GET G_curNode, TY_FN_PRE)
  ret _stk;

FN _out
  $declVar(declL compFn,  0, RSIZE)  $declEnd
  updateCompFn(fnRef:_out) -> SET compFn;
  _varImpl(0);       GET compFn -> SET G_compFn; ret;
pub syn FN out  notNow; 
  assert(getCState(C_FN_STATE) >= FN_STATE_STK, E_fnStateOut);
  setCState(FN_STATE_INP, C_FN_STATE) \ start inp state
  ret _out;

$STORE_PRIV
pre FN testVar \ x -> x + 1
  var x: U1 $declEnd  \x -> SET x; ret inc(GET x)
$tAssertEq(testVar(0x101), 2)

\ **********
\ * [4] if elif else, also $if ...
$STORE_PUB

\ cDat to Slc
fn cToSlc stk(cdat: &U1) -> out(dat: &U1, len: U2) do (
  ret (inc(dup\cdat) \(cdat, dat) -> swp -> ft1(\cdat))
)

\ TODO: I can remove recursion here and use a loop instead
fn _if do ( \ [] recursive fn of `if`
  var h: &U1  $declEnd
  scan; single(FALSE) \ compile token after `if`
  xx:IF(FALSE\asNow) -> SET h \ compile IF
  expectToken(SLC_DO, E_cToken) -> drp;
  scan; single(FALSE); \ compile token after `do`
  IF(scan; tokenEq(SLC_ELIF))
    xx:ELSE(GET h, FALSE\asNow) -> SET h;
    _if; \ recurse for next elif/else clause
  ELSE IF(tokenEq(SLC_ELSE))
    xx:ELSE(GET h, FALSE\asNow) -> SET h;
    scan; single(FALSE);
  ELSE tokenPlcSet(0); \ reset token (peeking)
  END END 
  ret _END(GET h, dup)
)

fn _ifNowLogic stk(done: Slot) -> out(a: Slot) do (
  IF(dup\done) 
    _comment; expectToken(SLC_DO, E_cToken) -> drp; 
    _comment; ret \done; END
  drp\done;  scan; single(TRUE) -> \ifChk;
  expectToken(SLC_DO, E_cToken) -> drp;
  expectToken(SLC_PAREN, E_needParen) -> drp; tokenPlcSet(0);
  IF(\ifChk) compNext(FALSE); ret TRUE; END
  _comment; ret FALSE;
)

FN _ifNow \ [] fn of `if` for the asNow case
  _ifNowLogic(FALSE) \ {done}
  LOOP l0
  IF(scan; tokenEq(SLC_ELIF))
    _ifNowLogic(\done); AGAIN l0
  ELSE IF(tokenEq(SLC_ELSE))
    IF(\done) _comment;
    ELSE      compNext(FALSE)  END
  ELSE drp\done; tokenPlcSet(0); \ reset token (peeking)
  END END ret;

syn fn if do (IF(\asNow) _ifNow; ELSE _if; END ret;)

$STORE_PRIV
fn testIf2 stk(a:Slot) -> out(b:Slot) do ( \ converts 1->4, 2->7, else: 13
  if(dup == 1)  do (drp; ret 4)
  elif(\a == 2) do (     ret 7)
  ret (0x99)
)
$tAssertEq(testIf2(1), 4)      $tAssertEq(testIf2(2), 7)
$tAssertEq(testIf2(12), 0x99)  $assertNoWs

fn testManyElif inp(a:Slot) -> out(b:Slot) do ( \ [a -> b] ...
  if   (GET a < 0x10) do ret(0x1000 + GET a)
  elif (GET a < 0x20) do ret(0x2000 + GET a)
  elif (GET a < 0x30) do ret(0x3000 + GET a)
  elif (GET a < 0x40) do    (0x4000 + GET a) \ note: fallthrough
  else ret(0x10 + GET a);
  ret inc(\fallthrough);
)
$tAssertEq(testManyElif(0x5),  0x1005)  $tAssertEq(testManyElif(0x17), 0x2017)
$tAssertEq(testManyElif(0x22), 0x3022)  $tAssertEq(testManyElif(0x33), 0x4034)
$tAssertEq(testManyElif(0x55), 0x65)

$assertNoWs
$if(1) do ($0x42)           -> $tAssertEq(0x42)
$if(1) do ($0x42) else ($7) -> $tAssertEq(0x42)
$if 0  do ($0x42) else ($7) -> $tAssertEq(7)

$tAssertEq(if(1) do ($42) else ($3), 42)

$if 0 do ($0x42) elif(0) do ($3) elif(1) do ($0x44) else ($0x77)
$tAssertEq(0x44)

fn testIfNow do (ret($if(0) do (4) else (0x3F + 3)))  $assertNoWs
$tAssertEq(testIfNow, 0x42)


\ **********
\ * [5] struct
\ Structs are a dict node with a value to a root node, and type to a tyStream
\ of the struct fields. The byte structure is:
\
\   numFields:U1 | ... fields
\
\ struct Foo (
\   a: U2,
\   b: &U1,
\ )

\ **********
\ *   [5.a] utilities
$STORE_PUB
const LOC_LOCAL = 0;
const LOC_PRIV  = 1;
const LOC_PUB   = 2;

fn locBBA stk(l:U1) do ( \ -> out(_:&BBA)
  if(dup\l == LOC_LOCAL) do (drp; ret REF G_bbaLocal)
  elif(\l == LOC_PRIV  ) do (     ret GET G_bbaPriv)
  ret GET G_bbaPub;
)

fn nameLoc -> out(loc:U1) do ( \ where location names are stored
  if(C_LOCAL    msk GET G_cstate) do ret LOC_LOCAL
  if(C_PUB_NAME msk GET G_cstate) do ret LOC_PUB else ret LOC_PRIV;
)

fn bumpName stk(size:U2, aligned:U1) -> out(_: &U1) do (
  ret BBA_bump(\size, \aligned, locBBA(nameLoc));
)


\ **********
\ *   [5.a] struct declaration
pre fn needSzI do ( \ (value -> neededSzI)
  IF(dup\value < 0x100  ) drp; ret SZ1; END
  IF(   \value <= 0xFFFF)      ret SZ2; END
                               ret SZ4;
)
$tAssertEq(SZ1, needSzI(0))      $tAssertEq(SZ1, needSzI(1))
$tAssertEq(SZ2, needSzI(0x100))  $tAssertEq(SZ2, needSzI(0xFFFF))
$tAssertEq(SZ4, needSzI(0x10000))

\ Store current token to name memory
fn storeToken -> out(cname: &U1) do (
  bumpName(tokenPlc + 1, FALSE) \ {&cDat}
  memMove(inc(dup;\cDat), tokenDat, tokenPlc) \ {&cDat}
  sr1(tokenPlc, ovr\cDat)
  ret \cDat;
)

$STORE_PRIV
fn testStoreToken do (
  scan; storeToken -> tAssertEq(ft1(dup\name), 7)
  ret tAssert(slcEq(cToSlc(\name), |testing|))
)
$testStoreToken testing

$STORE_PUB
pre fn _constructedMeta stk(numRefs:U1) inp(node:Slot) -> out(m:U1) do ret (
  \numRefs jn META_CONSTRUCTED jn needSzI(GET node)
)
$tAssertEq(_constructedMeta(2, 0x21),    0x82)
$tAssertEq(_constructedMeta(2, 0x4321),  0x92)
$tAssertEq(_constructedMeta(1, 0x54321), 0xA1)

large fn storeNodeBe stk(tyNode: &Slot) do ret (
  var tyRef: &U1;
  needSzI(dup\tyNode)                  \ {tyNode szI}
  -> bumpName(szIToSz(dup\szI), FALSE) \ {&tyNode szI &tyRef}
  -> dup -> SET tyRef -> swp           \ {&tyNode &tyRef szI}
  -> srBeSzI; GET tyRef
)

$STORE_PRIV
\ reason for dup: cache to check for overwrite
$tAssertEq(ftBe2(storeNodeBe(0x321) -> dup), 0x321)
$tAssertEq(ftBe4(storeNodeBe(0x54321)),      0x54321)
$tAssertEq(ftBe2(\cached321),                0x321)
$STORE_PUB

\ Compile a struct field, which may be a block of fields.
large fn _field do ret (
  var compFn: &Slot; updateCompFn(fnRef:_field) -> SET compFn;
  IF(isFnAndSyn(dictRefMaybe(0)))
    single(FALSE) \ next token is syn, run it (it may run us)
  ELSE
    var r\tyItems: &U1; d_tyGet(GET G_curNode) -> SET r\tyItems;
    sr1(inc ft1(GET r\tyItems), GET r\tyItems) \ struct.ty.numFields += 1
    bumpName(1, FALSE) -> SET r\tyItem;
    storeToken -> drp;
    colon; var tyNode: &Slot; parseTy -> SET tyNode; \ {numRefs}
    assert(dup\numRefs < 8, E_cBadRefs)  assert(isTyDict(GET tyNode), E_cNotType)
    if isDictNative(GET tyNode) do (
      assert(dup\numRefs + (d_tyGet(GET tyNode) msk META_REF_MSK)
             < 8, E_cBadRefs)
      sr1(\numRefs + d_tyGet(GET tyNode) jn META_NAMED, GET r\tyItem)
    ) else (
      \ store the tyItem meta, then the tyNode reference
      sr1(_constructedMeta(\numRefs, GET tyNode) jn META_NAMED, GET r\tyItem)
      storeNodeBe(GET tyNode) -> drp;
    )
  END
  GET compFn -> SET G_compFn;
)

\ Define a struct
large syn fn struct do (  notNow;
  dictAdd(NULL, $L(C_TYPED jn TY_DICT jn TY_DICT_STRUCT)) -> SET G_curNode;
  var tyItems: &U1; bumpName(1, FALSE\aligned) -> SET tyItems;
  d_tySet(GET tyItems, GET G_curNode);
  sr1(0\numFields, GET tyItems);
  _field;
  ret;
)

\ **********
\ *   [5.b] Important Structs and a few struct functions

pub struct DNode (
  l: &DNode;  r: &DNode;
  ckey: &U1;  v: Slot;    m: U2;
)

struct FieldCtx ( offset: U2; tyItem: &U1 )

fn isTyStruct stk(node: &DNode) -> out(_:U1) do (
  isTyDict(dup\node) -> swp -> isDictStruct(\node) -> and -> ret;
)
$tAssertNot(isTyStruct(dnode:U1))
$tAssert   (isTyStruct(dnode:DNode))
$tAssertEq(5, ft1(d_tyGet(dnode:DNode))) \ DNode has 5 fields
$tAssertEq( \ field `l` is ref to DNode
  ft1(inc d_tyGet(dnode:DNode)),
  META_CONSTRUCTED + META_NAMED + needSzI(dnode:DNode) + 1\refs)
$tAssertEq(ft1(2 + d_tyGet(dnode:DNode)), 1)   \ "l" name has len=1
$tAssertEq(ft1(3 + d_tyGet(dnode:DNode)), 0cl)

\ **********
\ *   [5.b] Working with a tystream

inline fn tyItem_refs stk(tyItem: &U1) -> out(refs:U1) do ret
  ( $h1(3) ft1(\tyItem) msk META_REF_MSK )

inline fn tyItem_isConstructed stk(tyItem: &U1) -> out(_:U1) do ret
  ( $h1(4) ft1(\tyItem) msk META_CONSTRUCTED )

inline fn tyItem_isNamed stk(tyItem: &U1) -> out(_:U1) do ret
  ( $h1(4) ft1(\tyItem) msk META_NAMED )


\ Skip a name to get the type reference
fn tyItem_skipName stk(tyItem: &U1) -> out(dat: &U1) do (
  if tyItem_isNamed(dup\tyItem) do ( \ skip name
    ret (dup\tyItem + inc2 ft1(inc\tyItem;)) \ tyItem + nameCount+2
  ) ret inc\tyItem;
)

\ Return the dictionary node for the tyItem
fn tyItem_node inp(tyItem: &U1) -> out(node: &DNode) do ret (
  assert(tyItem_isConstructed(GET tyItem), 0xB002\E_intern);
  ftBeSzI(tyItem_skipName(GET tyItem), ft1(GET tyItem) msk SZ_MASK)
)
$tAssertEq(tyItem_node(inc d_tyGet(dnode:DNode)), dnode:DNode)

\ Get the szI of a native tyItem
fn tyItem_nativeSzI stk(tyItem: &U1) -> out(refs:U1) do ret (
  assert(not tyItem_isConstructed(dup), E_intern);
  ft1(\tyItem) msk SZ_MASK
)

\ Get the size of a type item (native or struct).
fn tyItem_sz stk(tyItem: &U1) -> out(sz: U2) do ret (
  if(tyItem_refs(dup\tyItem)) do
    ( drp -> ret RSIZE; )
  if tyItem_isConstructed(dup\tyItem) do
    ret tySz(tyItem_node(\tyItem))
  szIToSz(ft1(\tyItem) msk SZ_MASK)
)


\ Point to the next tyItem in the tyItems.
fn tyItem_next inp(tyItem: &U1) -> out(_: &U1) do ret (
  tyItem_skipName(GET tyItem) \ {&out}
  if tyItem_isConstructed(GET tyItem) do (
    \out + szIToSz(ft1(GET tyItem) msk SZ_MASK) \ skip ref
  )
)

\ Manually assert all the field types in DNode, testing tyItem_(next|sz)
\ and struct at the same time.
$(
  inc d_tyGet(dnode:DNode) \ {tyItem0}  field l
  tAssertEq(tyItem_node(dup\tyItem0), dnode:DNode)
  tyItem_next(\tyItem0)     \ {tyItem1} field r
  tAssertEq(tyItem_node(dup\tyItem1), dnode:DNode)
  tyItem_next(\tyItem1)     \ {tyItem2} field ckey
  tAssertEq(ft1(dup\tyItem2), META_NAMED + SZ1 + 1)
  tAssertEq(tyItem_sz(dup\tyItem2), RSIZE)
  tyItem_next(\tyItem2)     \ {tyItem3} field v
  tAssertEq(ft1(dup\tyItem3), META_NAMED + SZR)
  tAssertEq(tyItem_sz(dup\tyItem3), RSIZE)
  tyItem_next(\tyItem3)     \ {tyItem4} field m
  tAssertEq(ft1(dup\tyItem4), META_NAMED + SZ2)
  tAssertEq(tyItem_sz(\tyItem4), 2)
)

\ **********
\ *   [XX.d] struct field walker and size

\ Bump the size by the add size.
\
\ This assumes that addSz behaves like a struct field and requires alignment.
fn bumpSz inp(curSz: U2, addSz: U2) -> out(newSz:U2) do (
  ret (align(GET curSz, reqAlign(GET addSz)) + GET addSz);
)
$tAssertEq(bumpSz(4, 1), 5)  $tAssertEq(bumpSz(4, 2), 6)
$tAssertEq(bumpSz(4, 3), 7)  $tAssertEq(bumpSz(5, 2), 8)
$tAssertEq(bumpSz(5, 4), 12) $tAssertEq(bumpSz(2, 8), 12)

\ Walk the tyItems, calling f for each one.
\
\ type of f [tyItem: &U1, ctx: &Any -> done:U1]
\
\ If f returns TRUE, return TRUE immediately.
\ Else, return FALSE after f has been executed with all tyItems.
fn tyItems_walk stk(tyItems: &U1) inp(ctx: &Slot, f: &Slot) -> out(done:U1)
do (
  \ type of f: fn [&tyItem &ctx -> stop:Bool]
  var numFields: U2; ft1(dup\tyItems) -> SET numFields;
  inc\(tyItems -> tyItem); LOOP l0  \ {tyItem}
    if(not GET numFields) do ( drp\tyItem; ret FALSE; )
    (dec GET numFields) -> SET numFields;
    if(xlw(dup\tyItem, GET ctx, GET f)) do ( drp\tyItem; ret TRUE; )
    tyItem_next(\tyItem);
  AGAIN l0
)

\ Walk a struct, updating the outSz for each tyItem.
fn _structSzWalker inp(tyItem: &U1, outSz: &U2) do (
  sr2(bumpSz(ft2(GET outSz), tyItem_sz(GET tyItem)), GET outSz);
  ret FALSE;
)

\declared fn struct_sz stk(s: &DNode) -> out(sz: U2) do (
  var sz: U2; 0 -> SET sz;
  assert(isTyStruct(dup\s), 0xB003\E_intern);
  tyItems_walk(d_tyGet(\s), REF sz, fnRef:_structSzWalker) -> drp;
  ret GET sz;
)
$tAssertEq(18\0x12, struct_sz(dnode:DNode));
$tAssertEq(8,       struct_sz(dnode:FieldCtx));


\ **********
\ *   [XX.e] struct field name offsets
$NEW_BLOCK_PUB
$NEW_BLOCK_PRIV
fn tyItem_cName stk(tyItem: &U1) -> out(cName: &U1) do ret (
  assert(tyItem_isNamed(dup\tyItem), 0xB004\E_intern) -> inc\tyItem;
)

\ Called by tyItems_walk for walking struct fields.
large fn _fieldNameWalker inp(tyItem: &U1, ctx: &FieldCtx) -> out(done:U1) do (
  if(tokenEq(cToSlc(tyItem_cName(GET tyItem)))) do (
    \ Found tyItem. Current offset is correct (after alignment)
    sroR:RSIZE(GET tyItem, GET ctx) \ ctx.tyItem = tyItem
    sr2( \ ctx.offset =
      align(ft2(GET ctx)\(ctx.offset), reqAlign(tyItem_sz(GET tyItem))),
      GET ctx)
    ret TRUE\done;
  )
  \ .ctx.offset = bumpSz(.ctx.offset, tySz(.tyItem))
  sr2(bumpSz(ft2(GET ctx), tyItem_sz(GET tyItem)), GET ctx);
  ret FALSE\done;
)

\ Get information about a struct field
large fn struct_fieldCtx stk(dnode: &DNode) inp(ctx: &FieldCtx) do ret (
  dv_log(dup\dnode, isTyStruct(dup\dnode), 0xC000, 3, 0x10)
  assert(isTyStruct(dup\dnode), E_type); scan;
  assert(
    tyItems_walk(d_tyGet(\node), GET ctx, fnRef:_fieldNameWalker),
    E_cNoKey);
)


fn consumeDot -> out(hasDot:U1) do (
  if(scan; not tokenEq(SLC_DOT)) do
    ( tokenPlcSet(0); ret FALSE; )
  ret TRUE;
)
$tAssert(consumeDot.)  $tAssertNot(consumeDot)

\ Return the node from the ctx and clear it (for safety)
large fn _ctxPopNode inp(ctx: &FieldCtx) -> out(_: &DNode) do ret (
  tyItem_node(ftoR:RSIZE(GET ctx)) \ {&Node}
  sroR:RSIZE(0, GET ctx)
)

\ Follow dots to find a field's offset and type
large fn struct_ctx inp(node: &DNode) -> out(offset:U2, tyItem: &U1) do (
  var ctxOffset: U2;  var ctxTyItem: &U1;
  0 -> SET ctxOffset; 0 -> SET ctxTyItem;
  if(not consumeDot) do ret (0, NULL); \ no dots, no offset or field
  struct_fieldCtx(GET node, REF ctxOffset) \ find first field
  LOOP l0
    \ Loop until there are no more dots. That field + offset is returned.
    if(not consumeDot) do ret (GET ctxOffset, GET ctxTyItem)
    tyItem_node(GET ctxTyItem) -> SET node;
    0 -> SET ctxTyItem;
    struct_fieldCtx(GET node, REF ctxOffset) \ find first field
  AGAIN l0
)
$tAssertEq(0,    struct_ctx(dnode:DNode).l -> drp\tyItem)
$tAssertEq(0x10, struct_ctx(dnode:DNode).m -> drp\tyItem)

\ **********
\ *   [XX] The dot compiler
\ The dot compiler allows us to use simpler syntax for (primarily) local
\ variables. It is the PRIMARY "syntax tree" of fngi, with the rest
\ being almost trivial concrete syntax around single tokens.
\
\ The dot compiler is invoked with the '.' token. For example:
\
\   .var          \ variable fetch
\   .var = (...)  \ variable store
\   .&var         \ variable reference (also function reference)
\   .@var         \ variable dereference
\   .@var = (...) \ variable dereference store
\
\   .var.field           \ variable field fetch
\   .var.field = (...)   \ variable field store
\   .&var.field          \ variable field reference
\   .@var.field = (...)  \ variable field dereference store

\ Okay here's what we do. The first token decides everything.
\ 1. If it's a local/global then it's just a lookup of field offset
\    (offset+type+references)
\ 2. Anything else, it's a dictionary lookup (NEVER a field)

\ IGNORE BELOW (probably)
\ Agh... I don't know how to do this.
\ WHAT exactly do I need to do? There are so many damn requirements here...
\ it is the OPPOSITE of simple!
\
\ Here's the first problem: I'm overloading this to do:
\ 1. local value and local field lookup (deep-struct as well!)
\ 2. local value and field setting (deep-struct as well!). I really don't think
\    this is even POSSIBLE without a syntax tree. If it is possible, it would be
\    such an enourmous pain I can't even begin!
\ 3. dictionary lookup, finding a function in a module (or struct!)
\ 4. god knows what else I wanted to do. Method lookup? Variant lookup?
\
\ This is WAY too much. A few notes:
\ 1. Following a bunch of dots on a TY_DICT is TRIVIAL. I could do that in
\    the base compiler whenever it encounters a dict type, and that is exactly what I
\    SHOULD do. It would effectively only find functions and constants.
\    - Alternatively: if the first item is a TY_DICT I could do that, otherwise
\      do locals/etc. But meh, I don't like that!
\ 2. '.' should just lookup value. Setting a value NEEDS to be done some other way,
\    other

\ Remove refs until there are 0 or 1. This allows FTO/FTLL/FTGL to work.
\ if/when a reference is fetched, offset will be set to 0
fn autoDeref stk(offset:U1, refs:U1) -> out(offset:U1, newRefs:U1) do (
  LOOP l0
    retIf(dup\refs < 2)
    if(swp -> dup\offset) do (
      h1($L(SZR + FTO)) -> h1(\offset) -> 0\offset
    ) else (
      h1($L(SZR + FT))
    ) -> swp -> dec;\refs
  AGAIN l0
)

$STORE_PRIV
$(
  autoDeref(4, 0) -> swp -> tAssertEq(4) -> tAssertEq(0)
  autoDeref(4, 1) -> swp -> tAssertEq(4) -> tAssertEq(1)
  autoDeref(4, 2) -> swp -> tAssertEq(0) -> tAssertEq(1)
  autoDeref(4, 3) -> swp -> tAssertEq(0) -> tAssertEq(1)
)
$STORE_PUB

\ Compile a deref. The final deref will use tySzI
fn fullDeref inp(tySzI:U1, tyRefs:U1, offset:U1, derefs:U1) do (
  assert(GET derefs <= GET tyRefs, E_cBadRefs)
  LOOP l0
    retIfNot(GET derefs)
    if(GET tyRefs == 1) do (
      assert(GET tySzI != 0xFF, E_cBadRefs)
      GET tySzI
    ) else SZR \ {szI}

    if(GET offset) do (
      h1(\szI + FTO); h1(GET offset);
    ) else h1(\szI + FT);
    dec GET derefs -> SET derefs;
    dec GET tyRefs -> SET tyRefs;
  AGAIN l0
)

\ Perform `.` for a local/global variable, walking the dots
\ i.e: `.myStruct.fieldStruct.field`
\ - Continue to add local offset (in Ctx) until a reference type is
\   encountered.
large fn _dotLocal inp(node: &DNode, synRefs: U1, synDerefs: U1) do (
  dv_log(0xD000, 1, 0x10)
  \ Create the local "ctx" struct from two vars. Requires manual alignment
  var _align: U2; var ctxOffset: U2;  var ctxTyItem: &U1;
  $dv_log(d_vGet(dnode:ctxOffset), d_vGet(dnode:ctxTyItem), 0x999, 3, 0x10)

  0 -> SET ctxOffset; 0 -> SET ctxTyItem;
  dv_log(0xD001, 1, 0x10)
  \ Extract metadata from node and use type instead.
  var varRefs: U1; d_mGet(GET node) msk TY_VAR_REF -> SET varRefs;
  var isLocal: U1; TRUE -> SET isLocal;
  d_tyGet(GET node) -> SET node;

  dv_log(0xD002, 1, 0x10)
  consumeDot -> BREAK0 b0
  dv_log(0xD003, 1, 0x10)
  struct_fieldCtx(GET node, REF ctxOffset) \ find first field
  LOOP l0
    dv_log(GET ctxTyItem, GET ctxOffset, 0xD010, 3, 0x10)
    \ At this point there is either a local or a single-reference value.
    \ We need to get the next field. There are a few possibilities:
    \  1. There is no next field -> we break to handle the value.
    \  2. The next field item is an embedded struct -> we increment offset.
    \     This works whether isLocal is true/false
    \  3. The next field item is a reference. We update the number of
    \     references appropriately.
    consumeDot -> BREAK0 b1
    dv_log(0xD011, 1, 0x10)

    \ If isLocal (we have field of local struct) then we need to get the local
    \ offset to "convert" the value to a reference on the stack.
    \ Note: We don't decrement varRefs since the type on the stack has that
    \   number of references in front of it.
    \ Note2: the varRefs can become non-zero either from a local that is
    \   a reference `var s: &MyStruct` or from a field which is a reference
    \   `nonRef.aRef.b`
    if(GET isLocal and GET varRefs) do (
      h1($L(SZR + FTLL)) h1(GET ctxOffset)
      0 -> SET ctxOffset; FALSE -> SET isLocal;
    )
    autoDeref(GET ctxOffset, GET varRefs) -> SET varRefs -> SET ctxOffset;
    tyItem_node(GET ctxTyItem) -> SET node;
    0 -> SET ctxTyItem;
    struct_fieldCtx(GET node, REF ctxOffset) \ updates ctx offset and tyItem
    tyItem_refs(GET ctxTyItem) -> SET varRefs
  AGAIN l0  END_BREAK b0  END_BREAK b1
  dv_log(0xD100, 1, 0x10)

  \ We are now at the "final" field in a struct (no more dots) or have a direct
  \ local value. We need to:
  \ - apply any refs. This is only valid if isLocal is still true!
  \ - apply any derefs. We must assert the type has a suitable number of refs!
  \ - simply fetch a native value.
  if(GET synRefs) do (
    assert(GET isLocal, E_type)
    h1(LR) h1(GET ctxOffset)
    ret;
  )
  dv_log(0xD105, 1, 0x10)

  \ Find the "native size" of the final type
  if(GET ctxTyItem) do (
    if(tyItem_isConstructed(GET ctxTyItem)) do 0xFF \ invalid szI
    else tyItem_nativeSzI(GET ctxTyItem)
  ) else (
    dv_log(0xD107, 1, 0x10)
    dv_log(GET node, 0xD108, 2, 0x10)
    \ TODO: assert is type, handle functions
    if(isDictNative(GET node)) do (
      d_tyGet(GET node) msk SZ_MASK
    ) else 0xFF \ invalid szI
  ) \ {tySzI}
  dv_log(dup\tySzI, GET varRefs, GET isLocal, 0xD110, 4, 0x10)

  \ If the variable is still "local" we need to actually fetch it
  if(GET isLocal) do (
    if(GET varRefs) do ( h1($L(SZR + FTLL)) h1(GET ctxOffset) )
    else (
      \ The variable is local and not a reference. Derefs are illegal
      dv_log(dup\tySzI, 0xD111, 2, 0x10)
      assertSzI(dup\tySzI)
      assertEq(0, GET synDerefs, E_cBadRefs)
      h1(\tySzI + FTLL) h1(GET ctxOffset)
      ret;
    )
  )

  dv_log(GET varRefs, GET synDerefs, 0xD0FF, 3, 0x10)
  ret fullDeref(\tySzI, GET varRefs, GET ctxOffset, GET synDerefs)
)

syn large fn . do ret ( notNow;
  var synRefs: U1;    countChr(0c&) -> SET synRefs;
  var synDerefs:  U1; countChr(0c@) -> SET synDerefs;
  dv_log(0x1000, 1, 0x10)
  if(GET synRefs) do assertNot(GET synDerefs, E_type);
  assert(GET synRefs < 2, E_type);

  dictRef(NULL) \ {&root}

  dv_log(dup, 0x1001, 2, 0x10)
  if(isTyLocal(dup\root)) do
    ( ret _dotLocal(\root, GET synRefs, GET synDerefs) )

  panic E_unimpl
)


$STORE_PRIV
fn testDotX inp(x:U1) -> out(_:U1) do ret .x
$tAssertEq(0x42, testDotX(0x42))
$tAssertEq(0x21, testDotX(0x321))

\ manually store to ctx.offset then get it
large fn testDotCtx -> out(_:U2) do
  ret ( var ctx: FieldCtx; sr2(0x7788, REF ctx); .ctx.offset )
$tAssertEq(0x7788, testDotCtx;)

\ TODO: still need to do:
\  1. .foo = bar
\  2. struct inp (assign values)
\  3. .deStruct
\  4. namespacing

$STORE_PUB
