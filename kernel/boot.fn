\ TODO: see notes/ufn.md for current thoughts

\ Bootstraps the fngi language.
\ Requires: boot.sp
\
\ Note: at this stage the language is severely restricted and several
\ pieces of the language are incomplete. Any CAPITAL items like FN, IF, LOOP
\ etc do not behave in the way their lower-case counterparts will behave.
\ Refer to boot.sp for all documentation.
$fngi  $STORE_PUB

\ **********
\ * [1] Extra core functions
syn FN =  panic(E_cToken)    \ prevent hanging =
syn FN )  panic(E_cParen)    \ prevent hanging )
pub syn        FN dv      notNow; $c1(DV); jmp:h1(d_vGet(colonRef))
pub pre inline FN memSet  $h1(2) dv:DV_memSet  ret; \ [&dst v len]   "dst = v"
pub pre inline FN memCmp  $h1(2) dv:DV_memCmp  ret; \ [&a &b len -> cmp]
pub pre inline FN memMove $h1(2) dv:DV_memMove ret; \ [&dst &src len] "dst = src"
\ pub pre        FN memMove        dv:DV_memMove ret; \ [&dst &src len] "dst = src"
pub pre        FN memClr 0 -> swp -> ret memSet(\a, \0, \len); \ [&a len] clear

$tAssert(isFnPre(dnode:memMove))  $tAssert(isFnInline(dnode:memMove))

pub pre FN dictRefMaybe \ [&root -> &node(nullable)]
  scan;  DV_comp_dGet -> dv:DV_comp; ret;

inline pre FN >     $h1(2) swp -> (\b < \a;)  ret;     \ [a b -> a > b]
inline pre FN <=    $h1(2) swp -> (\b >= \a;) ret;     \ [a b -> a <= b]
$(tAssert(2 > 1)  tAssertNot(2 > 2)  tAssert(2 <= 2)  tAssertNot(2 <= 1))

inline pre FN le_s  $h1(2) swp -> (\b ge_s \a;)  ret;  \ [a b -> a <= b]
inline pre FN gt_s  $h1(2) swp -> (\b lt_s \a;)  ret;  \ [a b -> a >= b]
$tAssert(gt_s(neg 1, neg 2)) $tAssertNot(gt_s(neg 2, neg 2))
$tAssert(gt_s(2, neg 7))
$tAssert(le_s(neg 2, neg 2)) $tAssert(le_s(neg 3, neg 2))
$tAssert(le_s(neg 1, 100))

pre FN compNext \ [asNow]
  $declVar(declL compFn,           0, RSIZE) $declEnd
  IF(\asNow) fnRef:_now;  ELSE  fnRef:baseCompFn;  END
  dup\fnRef -> updateCompFn(\fnRef) -> SET compFn \ {fnRef}
  xlw(\fnRef);  ret(GET compFn -> SET G_compFn)

\ **********
\ * [2] Inline slices: strings and tokens
pub syn FN |  notNow; \ [-> dat len] Define a string slice
  h1(SZ1 + SLC); heap; h1(0); \ {start}
  LOOP l0  charNextEsc; \ {start, char, unknownEscape}
    IF (\unknownEscape) assert(dup\char == 0c|, E_cStr);
    ELSE IF (dup\char == 0c|)
      drp\char; (heap - ovr\start) -> dec; \ {start len}
      assert(0xFF >= ovr\len, E_cNotFit);
      swp; sr1(\len, \start); ret;
    END END  h1(\char);
  AGAIN l0
$STORE_PRIV
FN helloWorld  ret |Hello World!|  \ [-> dat len]
$tAssertEq(helloWorld, 12); \ len == 12
$tAssertEq(ft1(dup\dat), 0cH);  $tAssertEq(ft1(inc(\dat)), 0ce); \ "He"

$STORE_PUB
pub pre FN slcCmp \ [&a aLen &b bLen -> cmp]
  $declVar(declL b,    TY_VAR_INPUT, RSIZE)
  $declVar(declL bLen, TY_VAR_INPUT, RSIZE)
  $declEnd
  IF(dup\aLen < GET bLen) drp; drp; ret(neg 1); END
  IF(   \aLen > GET bLen)      drp; ret(    1); END
  ret memCmp(\a, GET b, GET bLen)
pub pre FN slcEq  ret(slcCmp() == 0)
pub pre FN tokenEq ret(slcEq(\(...), tokenDat, tokenPlc))

$STORE_PRIV
FN helloBobby  ret |Hello Bobby!|  \ [-> dat len]
$tAssert   (slcEq(helloWorld, helloWorld))
$tAssertNot(slcEq(helloWorld, helloBobby))
$tAssertEq(slcCmp(helloWorld, helloWorld),     0) \ is equal
$tAssert(  slcCmp(helloWorld, 0, 42)      lt_s 0) \ different lengths
$tAssert(  slcCmp(helloWorld, helloBobby) gt_s 0) \ different contents

$STORE_PUB
FN SLC_DO     ret |do|
FN SLC_DOT    ret |.|
FN SLC_ELIF   ret |elif|
FN SLC_ELSE   ret |else|
FN SLC_EQUAL  ret |=|
FN SLC_PAREN  ret |(|
FN SLC_BRACK_O ret |[|
FN SLC_BRACK_C ret |]|

pre FN expectToken \ [<token/s> slc err -> &node(nullable)]
  $declVar(declL err, TY_VAR_INPUT, RSIZE)
  $declVar(declL node, 0, RSIZE)  $declEnd
  dictRefMaybe(0) -> SET node; \ {slc}
  assert(tokenEq(\slc), GET err)
  ret GET node

pre pub FN conEquals \ [`= token` asNow -> ?value]
  expectToken(SLC_EQUAL, E_needEqual) -> drp;
  ret compNext(\asNow)

pub syn FN const  \ `const token = token`
  $declVar(declL node, 0, RSIZE)  $declEnd
  notNow; dictAdd(0, 0) -> SET node;
  ret d_vSet(conEquals(TRUE), GET node)

$STORE_PRIV
const const42 = 0x42;         $tAssertEq(const42, 0x42)
const const49 = (0x42 + 7);   $tAssertEq(const49, 0x49)
$STORE_PUB

pre FN isTyped      ret( d_mGet(\node) msk C_TYPED )
pre FN d_tyGet \ {&DNode -> ty}
  assert(isTyped(dup\dnode), E_intern) -> ret ftoR:DN_ty;

pre FN d_tySet \ {&ty &DNode}
  assert(isTyped(dup\dnode), E_intern) -> ret sroR:DN_ty;

\ declTy:token(meta, ty) manually declare a dictionary entry
pub syn FN declTy ret (
  $declVar(declL node, 0, RSIZE) $declEnd
  notNow; colon; xx:dictAdd(0\v, C_TYPED\m) -> SET node;
  compNext(TRUE) -> swp -> d_mSet(\meta, GET node) -> d_tySet(\ty, GET node);
)

\ **********
\ * [XX] Type Scafolding and Native Type Implementation
\ Types are implemented from TY_DICT Dictionary Nodes. They have the following meta:
\
\ 11-- -CCC C=category (Native, Bitmap, Struct, etc)
\
\ The "value" in the DNode is then:
\ * MOD / SUBMOD: pointer to the root of the sub-dictionary.
\ * NATIVE: a single tyItem byte (with C=0 N=0)
\ * else: a pointer to a tyStream
\
\ A tyStream is a single byte specifying the number of tyItems, followed by
\ the tyItems (unaligned).
\
\ All tyItems start with a byte:
\    CN-- ----   C=constructed  N=named
\
\ If N=1, then the next bytes are the counted name (U1 length followed by data)
\
\ If C=0, it is not constructed, meaning it is a native type. In this case:
\    0NZZ SRRR  N=named  Z=size  R=reference depth  S=signed
\ - (Z) The sizes are the same as instructions
\ - (R) The reference depth is a count of the number of `&` in the type.
\
\ If C=1 it is constructed, the meta is:
\     1NTT -RRR
\ N=named  T=SzI of type reference (pointer)  R=reference depth
\
\ Then there is T size bytes of the type reference.
const TY_DICT_MSK    = 0x07;
const TY_DICT_NATIVE = 0x00;
const TY_DICT_BITMAP = 0x01;
const TY_DICT_STRUCT = 0x02;
const TY_DICT_ENUM   = 0x03;
const TY_DICT_MOD    = 0x04;
const TY_DICT_SUBMOD = 0x05;

const META_CONSTRUCTED   = 0x80;
const META_NAMED         = 0x40;
const META_REF_MSK       = 0x07;
const META_NATIVE_SIGNED = 0x08;
const _native = (C_TYPED jn TY_DICT jn TY_DICT_NATIVE)

declTy:U1    (_native,                       SZ1)
declTy:U2    (_native,                       SZ2)
declTy:U4    (_native,                       SZ4)
declTy:Slot  (_native,                       SZR)
declTy:I1    (_native, META_NATIVE_SIGNED jn SZ1)
declTy:I2    (_native, META_NATIVE_SIGNED jn SZ2)
declTy:I4    (_native, META_NATIVE_SIGNED jn SZ4)
declTy:ISlot (_native, META_NATIVE_SIGNED jn SZR)

pre FN isTyDict     ret((d_mGet(\node) msk META_TY_MASK) == TY_DICT      )
pre FN isDictNative ret((d_mGet(\node) msk TY_DICT_MSK) == TY_DICT_NATIVE)
pre FN isDictStruct ret((d_mGet(\node) msk TY_DICT_MSK) == TY_DICT_STRUCT)
$tAssert(isTyDict(dnode:U1))
$tAssert(isDictNative(dnode:U1))

\ **********
\ * [XX] fn
\ fn myFn stk(a:U1 b:U2) inp c:U2; var i:U2; inp d:Ref
\ -> out(x:Ref y:Ref) do (
\   var i:U2 = 7;
\   ... code
\   var j:U2 = 10;
\   ... code
\ )
$STORE_PUB

pre FN isFnAndSyn \ {&node}
  retIfNot(dup)
  IF(not isTyFn(dup)) drp; ret FALSE END
  ret isFnSyn(\node);
$tAssertNot(isFnAndSyn(dnode:isFnAndSyn))
$tAssert   (isFnAndSyn(dnode:FN))

pub syn FN fn
  $declVar(declL meta,    0, RSIZE) $declEnd notNow;
  GET G_metaNext -> SET meta;
  dictRefMaybe(0) -> IF(dup\key) \ fn already exists
    assert(isFnDeclare(dup\key), E_cKey); \ {&key}
    d_vGet(dup\key) -> heap -> swp \ {&key heap &declFn}
    srBeR(\heap, \declFn) \ {&key}
  ELSE
    drp\key; tokenPlcSet(0); \ clear token
    dictAdd(0, GET G_metaNext jn TY_FN)
  END -> _FN(\key)
  IF(isMetaFnDeclare(GET meta))  srBeR(0, bump(RSIZE, FALSE))  END
  LOOP l0
    dictRefMaybe(0) \ {&Node}
    IF(tokenEq(SLC_DO)) \ function body
      drp\node; declInpEnd; scan; single(FALSE); ret declFnEnd;
    END
    assert(isFnAndSyn(\node), E_fnSyn); single(FALSE) \ compile syn fns
  AGAIN l0

$STORE_PRIV
pre fn testFn \(a:Slot b:U2 -> b a) do ( swp -> ret; )
$(testFn(0x4321, 0x54321) -> tAssertEq(0x4321) -> tAssertEq(0x54321))

declare fn testDeclared do ()                    \ [-> U1]
fn testDeclaredUsed do ( ret testDeclared; ) \ [-> U1]
fn testDeclared do ( ret 3; )               \ [-> U1]

$STORE_PUB
\ **********
\ * [XX] function declaration syntax (var, inp, out)
declare large pre fn struct_sz \(s: &DNode -> sz:U2) do;

pre FN tySz \ {node:&DNode -> szBytes}
  assert(isTyDict(dup), 0xB001\E_intern)
  IF(isDictNative(dup)) ret szIToSz(d_tyGet(\node) msk SZ_MASK) END
  IF(isDictStruct(dup)) ret struct_sz(\node)                   END
  panic(E_unimpl) \ TODO: other types
$tAssertEq(1,     tySz(dnode:U1))
$tAssertEq(2,     tySz(dnode:I2))
$tAssertEq(RSIZE, tySz(dnode:ISlot))

pre FN countChr \ [chr -> numChr] and advance past them
  0\(chr, count) -> LOOP l0;
    swp \ {count chr}
    IF(dup\chr == peekChr) swp; inc(\count); tokenPlcSet(1);
    ELSE         drp\chr; ret \count; END
  AGAIN l0
$tAssertEq(countChr(0c&) & &&, 3)   $tAssertEq(countChr(0c&) 0)

FN parseTy \ [-> numRefs &DNode]
  $declVar(declL node,    0, RSIZE) $declEnd
  countChr(0c&); ret assert(isTyDict(dictRef(0) -> dup), E_needType)
$tAssertEq(parseTy &&U1, dnode:U1)   -> $tAssertEq(\numRefs, 2)
$tAssertEq(parseTy Slot, dnode:Slot) -> $tAssertEq(\numRefs, 0)

pre FN _varImpl \ [meta]
  $declVar(declL meta, TY_VAR_INPUT, 1) $declEnd
  IF(isFnAndSyn(dictRefMaybe(0)))
    ret single(FALSE) \ next token is syn, run it (it may run us)
  END
  tokenPlcSet(0); \ make dictRefMaybe a peek
  IF(GET meta)
    declL -> colon -> parseTy; \ {&Local isLocal=1 numRefs &Type}
  ELSE
    0, 1 -> _comment -> colon -> parseTy; \ {NULL, isLocal=1, numRefs, &Type}
  END
  \ TODO: register type
  IF(swp\numRefs) drp; RSIZE
  ELSE            tySz(\type);  END \ {&Local isLocal szBytes}

  IF(GET meta)  GET meta -> swp -> declVar;
  ELSE \stk     drp; drp; drp; END
  ret;

FN _inp
  $declVar(declL compFn,  0, RSIZE)  $declEnd
  updateCompFn(fnRef:_inp) -> SET compFn;
  _varImpl($L(TY_VAR jn TY_VAR_INPUT))
  GET compFn -> SET G_compFn; ret;
pub syn FN inp
  notNow; assert(getCState(C_FN_STATE) >= FN_STATE_STK, E_fnStateInp)
  setCState(FN_STATE_INP, C_FN_STATE) \ start inp state
  keyJnMeta(GET G_curNode, TY_FN_PRE)
  _inp; ret;

$STORE_PRIV
\ test inp by truncating values
pre FN testInp  inp x:U1 $declEnd  ret(GET x)
$tAssertEq(testInp(0x101), 1)

pre FN testInp3  inp (x:U1  y:U2  z: &U1)  $declEnd
  ret(GET x, GET y, GET z)
$testInp3(0x101\U1, 0x12345\U2, 0x6789ABC\reference)
$tAssertEq(0x6789ABC)  $tAssertEq(0x2345)  $tAssertEq(0x01)

$STORE_PUB
FN _var
  $declVar(declL compFn,  0, RSIZE)  $declEnd
  updateCompFn(fnRef:_var) -> SET compFn;
  _varImpl(TY_VAR);  GET compFn -> SET G_compFn; ret;
pub syn FN var  notNow;
  assert(getCState(C_FN_STATE) != FN_STATE_NO, E_fnStateVar); 
  ret _var;

FN _stk
  $declVar(declL compFn,  0, RSIZE)  $declEnd
  updateCompFn(fnRef:_stk) -> SET compFn;
  _varImpl(0);       GET compFn -> SET G_compFn; ret;
pub syn FN stk  notNow; 
  assertEq(getCState(C_FN_STATE), FN_STATE_STK, E_fnStateStk);
  keyJnMeta(GET G_curNode, TY_FN_PRE)
  ret _stk;

FN _out
  $declVar(declL compFn,  0, RSIZE)  $declEnd
  updateCompFn(fnRef:_out) -> SET compFn;
  _varImpl(0);       GET compFn -> SET G_compFn; ret;
pub syn FN out  notNow; 
  assert(getCState(C_FN_STATE) >= FN_STATE_STK, E_fnStateOut);
  setCState(FN_STATE_INP, C_FN_STATE) \ start inp state
  ret _out;

$STORE_PRIV
pre FN testVar \ x -> x + 1
  var x: U1 $declEnd  \x -> SET x; ret inc(GET x)
$tAssertEq(testVar(0x101), 2)

\ **********
\ * [4] if elif else, also $if ...
$STORE_PUB

\ cDat to Slc
fn cToSlc stk(cdat: &U1) -> out(dat: &U1, len: U2) do (
  ret (inc(dup\cdat) \(cdat, dat) -> swp -> ft1(\cdat))
)

\ TODO: I can remove recursion here and use a loop instead
fn _if do ( \ [] recursive fn of `if`
  var h: &U1  $declEnd
  scan; single(FALSE) \ compile token after `if`
  xx:IF(FALSE\asNow) -> SET h \ compile IF
  expectToken(SLC_DO, E_cToken) -> drp;
  scan; single(FALSE); \ compile token after `do`
  IF(scan; tokenEq(SLC_ELIF))
    xx:ELSE(GET h, FALSE\asNow) -> SET h;
    _if; \ recurse for next elif/else clause
  ELSE IF(tokenEq(SLC_ELSE))
    xx:ELSE(GET h, FALSE\asNow) -> SET h;
    scan; single(FALSE);
  ELSE tokenPlcSet(0); \ reset token (peeking)
  END END 
  ret _END(GET h, dup)
)

fn _ifNowLogic stk(done: Slot) -> out(a: Slot) do (
  IF(dup\done) 
    _comment; expectToken(SLC_DO, E_cToken) -> drp; 
    _comment; ret \done; END
  drp\done;  scan; single(TRUE) -> \ifChk;
  expectToken(SLC_DO, E_cToken) -> drp;
  expectToken(SLC_PAREN, E_needParen) -> drp; tokenPlcSet(0);
  IF(\ifChk) compNext(FALSE); ret TRUE; END
  _comment; ret FALSE;
)

FN _ifNow \ [] fn of `if` for the asNow case
  _ifNowLogic(FALSE) \ {done}
  LOOP l0
  IF(scan; tokenEq(SLC_ELIF))
    _ifNowLogic(\done); AGAIN l0
  ELSE IF(tokenEq(SLC_ELSE))
    IF(\done) _comment;
    ELSE      compNext(FALSE)  END
  ELSE drp\done; tokenPlcSet(0); \ reset token (peeking)
  END END ret;

syn fn if do (IF(\asNow) _ifNow; ELSE _if; END ret;)

$STORE_PRIV
fn testIf2 stk(a:Slot) -> out(b:Slot) do ( \ converts 1->4, 2->7, else: 13
  if(dup == 1)  do (drp; ret 4)
  elif(\a == 2) do (     ret 7)
  ret (0x99)
)
$tAssertEq(testIf2(1), 4)      $tAssertEq(testIf2(2), 7)
$tAssertEq(testIf2(12), 0x99)  $assertNoWs

fn testManyElif inp(a:Slot) -> out(b:Slot) do ( \ [a -> b] ...
  if   (GET a < 0x10) do ret(0x1000 + GET a)
  elif (GET a < 0x20) do ret(0x2000 + GET a)
  elif (GET a < 0x30) do ret(0x3000 + GET a)
  elif (GET a < 0x40) do    (0x4000 + GET a) \ note: fallthrough
  else ret(0x10 + GET a);
  ret inc(\fallthrough);
)
$tAssertEq(testManyElif(0x5),  0x1005)  $tAssertEq(testManyElif(0x17), 0x2017)
$tAssertEq(testManyElif(0x22), 0x3022)  $tAssertEq(testManyElif(0x33), 0x4034)
$tAssertEq(testManyElif(0x55), 0x65)

$assertNoWs
$if(1) do ($0x42)           -> $tAssertEq(0x42)
$if(1) do ($0x42) else ($7) -> $tAssertEq(0x42)
$if 0  do ($0x42) else ($7) -> $tAssertEq(7)

$tAssertEq(if(1) do ($42) else ($3), 42)

$if 0 do ($0x42) elif(0) do ($3) elif(1) do ($0x44) else ($0x77)
$tAssertEq(0x44)

fn testIfNow do (ret($if(0) do (4) else (0x3F + 3)))  $assertNoWs
$tAssertEq(testIfNow, 0x42)


\ **********
\ * [5] struct
\ Structs are a dict node with a value to a root node, and type to a tyStream
\ of the struct fields. The byte structure is:
\
\   numFields:U1 | ... fields
\
\ struct Foo (
\   a: U2,
\   b: &U1,
\ )

\ **********
\ *   [5.a] utilities
$STORE_PUB
const LOC_LOCAL = 0;
const LOC_PRIV  = 1;
const LOC_PUB   = 2;

fn locBBA stk(l:U1) do ( \ -> out(_:&BBA)
  if(dup\l == LOC_LOCAL) do (drp; ret REF G_bbaLocal)
  elif(\l == LOC_PRIV  ) do (     ret GET G_bbaPriv)
  ret GET G_bbaPub;
)

fn nameLoc -> out(loc:U1) do ( \ where location names are stored
  if(C_LOCAL    msk GET G_cstate) do ret LOC_LOCAL
  if(C_PUB_NAME msk GET G_cstate) do ret LOC_PUB else ret LOC_PRIV;
)

fn bumpName stk(size:U2, aligned:U1) -> out(_: &U1) do (
  ret BBA_bump(\size, \aligned, locBBA(nameLoc));
)


\ **********
\ *   [5.a] struct declaration
pre fn needSzI do ( \ (value -> neededSzI)
  IF(dup\value < 0x100  ) drp; ret SZ1; END
  IF(   \value <= 0xFFFF)      ret SZ2; END
                               ret SZ4;
)
$tAssertEq(SZ1, needSzI(0))      $tAssertEq(SZ1, needSzI(1))
$tAssertEq(SZ2, needSzI(0x100))  $tAssertEq(SZ2, needSzI(0xFFFF))
$tAssertEq(SZ4, needSzI(0x10000))

\ Store current token to name memory
fn storeToken -> out(cname: &U1) do (
  bumpName(tokenPlc + 1, FALSE) \ {&cDat}
  memMove(inc(dup;\cDat), tokenDat, tokenPlc) \ {&cDat}
  sr1(tokenPlc, ovr\cDat)
  ret \cDat;
)

$STORE_PRIV
fn testStoreToken do (
  scan; storeToken -> tAssertEq(ft1(dup\name), 7)
  ret tAssert(slcEq(cToSlc(\name), |testing|))
)
$testStoreToken testing

$STORE_PUB
pre fn _constructedMeta stk(numRefs:U1) inp(node:Slot) -> out(m:U1) do ret (
  \numRefs jn META_CONSTRUCTED jn needSzI(GET node)
)
$tAssertEq(_constructedMeta(2, 0x21),    0x82)
$tAssertEq(_constructedMeta(2, 0x4321),  0x92)
$tAssertEq(_constructedMeta(1, 0x54321), 0xA1)

large fn storeNodeBe stk(tyNode: &Slot) do ret (
  var tyRef: &U1;
  needSzI(dup\tyNode)                  \ {tyNode szI}
  -> bumpName(szIToSz(dup\szI), FALSE) \ {&tyNode szI &tyRef}
  -> dup -> SET tyRef -> swp           \ {&tyNode &tyRef szI}
  -> srBeSzI; GET tyRef
)

$STORE_PRIV
\ reason for dup: cache to check for overwrite
$tAssertEq(ftBe2(storeNodeBe(0x321) -> dup), 0x321)
$tAssertEq(ftBe4(storeNodeBe(0x54321)),      0x54321)
$tAssertEq(ftBe2(\cached321),                0x321)
$STORE_PUB

\ Compile a struct field, which may be a block of fields.
large fn _field do ret (
  var compFn: &Slot; updateCompFn(fnRef:_field) -> SET compFn;
  IF(isFnAndSyn(dictRefMaybe(0)))
    single(FALSE) \ next token is syn, run it (it may run us)
  ELSE
    var r\tyItems: &U1; d_tyGet(GET G_curNode) -> SET r\tyItems;
    sr1(inc ft1(GET r\tyItems), GET r\tyItems) \ struct.ty.numFields += 1
    bumpName(1, FALSE) -> SET r\tyItem;
    storeToken -> drp;
    colon; var tyNode: &Slot; parseTy -> SET tyNode; \ {numRefs}
    assert(dup\numRefs < 8, E_cBadRefs)  assert(isTyDict(GET tyNode), E_cNotType)
    if isDictNative(GET tyNode) do (
      assert(dup\numRefs + (d_tyGet(GET tyNode) msk META_REF_MSK)
             < 8, E_cBadRefs)
      sr1(\numRefs + d_tyGet(GET tyNode) jn META_NAMED, GET r\tyItem)
    ) else (
      \ store the tyItem meta, then the tyNode reference
      sr1(_constructedMeta(\numRefs, GET tyNode) jn META_NAMED, GET r\tyItem)
      storeNodeBe(GET tyNode) -> drp;
    )
  END
  GET compFn -> SET G_compFn;
)

\ Define a struct
large syn fn struct do (  notNow;
  dictAdd(NULL, $L(C_TYPED jn TY_DICT jn TY_DICT_STRUCT)) -> SET G_curNode;
  var tyItems: &U1; bumpName(1, FALSE\aligned) -> SET tyItems;
  d_tySet(GET tyItems, GET G_curNode);
  sr1(0\numFields, GET tyItems);
  _field;
  ret;
)

\ **********
\ *   [5.b] Important Structs and a few struct functions

pub struct DNode (
  l: &DNode;  r: &DNode;
  ckey: &U1;  v: Slot;    m: U2;
)

struct Ctx ( offset: U2, tyItem: &U1 )

fn isTyStruct stk(node: &DNode) -> out(_:U1) do (
  isTyDict(dup\node) -> swp -> isDictStruct(\node) -> and -> ret;
)
$tAssertNot(isTyStruct(dnode:U1))
$tAssert   (isTyStruct(dnode:DNode))
$tAssertEq(5, ft1(d_tyGet(dnode:DNode))) \ DNode has 5 fields
$tAssertEq( \ field `l` is ref to DNode
  ft1(inc d_tyGet(dnode:DNode)),
  META_CONSTRUCTED + META_NAMED + needSzI(dnode:DNode) + 1\refs)
$tAssertEq(ft1(2 + d_tyGet(dnode:DNode)), 1)   \ "l" name has len=1
$tAssertEq(ft1(3 + d_tyGet(dnode:DNode)), 0cl)

\ **********
\ *   [5.b] Working with a tystream

\ Skip a name to get the type reference
fn tyItem_skipName stk(tyItem: &U1) -> out(dat: &U1) do (
  if(ft1(dup\tyItem) msk META_NAMED) do ( \ skip name
    ret (dup\tyItem + inc2 ft1(inc\tyItem;)) \ tyItem + nameCount+2
  ) ret inc\tyItem;
)

\ Return the dictionary node for the tyItem
fn tyItem_node inp(tyItem: &U1) -> out(node: &DNode) do ret (
  assert(ft1(GET tyItem) msk META_CONSTRUCTED, 0xB002\E_intern);
  ftBeSzI(tyItem_skipName(GET tyItem), ft1(GET tyItem) msk SZ_MASK)
)
$tAssertEq(tyItem_node(inc d_tyGet(dnode:DNode)), dnode:DNode)

\ Get the size of a type item (native or struct).
fn tyItem_sz stk(tyItem: &U1) -> out(sz: U2) do ret (
  if(ft1(dup\tyItem) msk META_REF_MSK) do
    ( drp -> ret RSIZE; )
  if (ft1(dup\tyItem) msk META_CONSTRUCTED) do
    ret tySz(tyItem_node(\tyItem))
  szIToSz(ft1(\tyItem) msk SZ_MASK)
)


\ Point to the next tyItem in the tyItems.
fn tyItem_next inp(tyItem: &U1) -> out(_: &U1) do ret (
  tyItem_skipName(GET tyItem) \ {&out}
  if(ft1(GET tyItem) msk META_CONSTRUCTED) do (
    \out + szIToSz(ft1(GET tyItem) msk SZ_MASK) \ skip ref
  )
)

\ Manually assert all the field types in DNode, testing tyItem_(next|sz)
\ and struct at the same time.
$(
  inc d_tyGet(dnode:DNode) \ {tyItem0}  field l
  tAssertEq(tyItem_node(dup\tyItem0), dnode:DNode)
  tyItem_next(\tyItem0)     \ {tyItem1} field r
  tAssertEq(tyItem_node(dup\tyItem1), dnode:DNode)
  tyItem_next(\tyItem1)     \ {tyItem2} field ckey
  tAssertEq(ft1(dup\tyItem2), META_NAMED + SZ1 + 1)
  tAssertEq(tyItem_sz(dup\tyItem2), RSIZE)
  tyItem_next(\tyItem2)     \ {tyItem3} field v
  tAssertEq(ft1(dup\tyItem3), META_NAMED + SZR)
  tAssertEq(tyItem_sz(dup\tyItem3), RSIZE)
  tyItem_next(\tyItem3)     \ {tyItem4} field m
  tAssertEq(ft1(dup\tyItem4), META_NAMED + SZ2)
  tAssertEq(tyItem_sz(\tyItem4), 2)
)

\ **********
\ *   [XX.d] struct field walker and size

\ Bump the size by the add size.
\
\ This assumes that addSz behaves like a struct field and requires alignment.
fn bumpSz inp(curSz: U2, addSz: U2) -> out(newSz:U2) do (
  ret (align(GET curSz, reqAlign(GET addSz)) + GET addSz);
)
$tAssertEq(bumpSz(4, 1), 5)  $tAssertEq(bumpSz(4, 2), 6)
$tAssertEq(bumpSz(4, 3), 7)  $tAssertEq(bumpSz(5, 2), 8)
$tAssertEq(bumpSz(5, 4), 12) $tAssertEq(bumpSz(2, 8), 12)

\ Walk the tyItems, calling f for each one.
\
\ type of f [tyItem: &U1, ctx: &Any -> done:U1]
\
\ If f returns TRUE, return TRUE immediately.
\ Else, return FALSE after f has been executed with all tyItems.
fn tyItems_walk stk(tyItems: &U1) inp(ctx: &Slot, f: &Slot) -> out(done:U1)
do (
  \ type of f: fn [&tyItem &ctx -> stop:Bool]
  var numFields: U2; ft1(dup\tyItems) -> SET numFields;
  inc\(tyItems -> tyItem); LOOP l0  \ {tyItem}
    if(not GET numFields) do ( drp\tyItem; ret FALSE; )
    (dec GET numFields) -> SET numFields;
    if(xlw(dup\tyItem, GET ctx, GET f)) do ( drp\tyItem; ret TRUE; )
    tyItem_next(\tyItem);
  AGAIN l0
)

\ Walk a struct, updating the outSz for each tyItem.
fn _structSzWalker inp(tyItem: &U1, outSz: &U2) do (
  sr2(bumpSz(ft2(GET outSz), tyItem_sz(GET tyItem)), GET outSz);
  ret FALSE;
)

\declared fn struct_sz stk(s: &DNode) -> out(sz: U2) do (
  var sz: U2; 0 -> SET sz;
  assert(isTyStruct(dup\s), 0xB003\E_intern);
  tyItems_walk(d_tyGet(\s), REF sz, fnRef:_structSzWalker) -> drp;
  ret GET sz;
)
$tAssertEq(18\0x12, struct_sz(dnode:DNode));
$tAssertEq(8,       struct_sz(dnode:Ctx));


\ **********
\ *   [XX.e] struct field name offsets
$NEW_BLOCK_PUB
fn tyItem_cName stk(tyItem: &U1) -> out(cName: &U1) do ret (
  assert(ft1(dup\tyItem) msk META_NAMED, 0xB004\E_intern) -> inc\tyItem;
)

\ Called by tyItems_walk for walking struct fields.
large fn _fieldNameWalker inp(tyItem: &U1, ctx: &Ctx) -> out(done:U1) do (
  if(tokenEq(cToSlc(tyItem_cName(GET tyItem)))) do (
    \ Found tyItem. Current offset is correct (after alignment)
    sroR:RSIZE(GET tyItem, GET ctx) \ ctx.tyItem = tyItem
    sr2( \ ctx.offset =
      align(ft2(GET ctx)\(ctx.offset), reqAlign(tyItem_sz(GET tyItem))),
      GET ctx)
    ret TRUE\done;
  )
  \ .ctx.offset = bumpSz(.ctx.offset, tySz(.tyItem))
  sr2(bumpSz(ft2(GET ctx), tyItem_sz(GET tyItem)), GET ctx);
  ret FALSE\done;
)

large fn struct_fieldCtx stk(dnode: &DNode) -> out(offset:U2, tyItem: &U1) do (
  assert(isTyStruct(dup\dnode), E_type); scan;
  var ctx: Ctx; memClr(REF ctx, $L(tySz(dnode:Ctx)));
  assert(
    tyItems_walk(d_tyGet(\node), REF ctx, fnRef:_fieldNameWalker),
    E_cNoKey);
  ret (ft2(REF ctx), ftoR:RSIZE(REF ctx));
)

\ large fn struct_fieldOffset stk(dnode: &DNode) -> out(offset:U2) do (
\   assert(isTyStruct(dup\dnode), E_type); scan;
\   var ctx: Ctx; memClr(REF ctx, $L(tySz(dnode:Ctx)));
\   assert(
\     tyItems_walk(d_tyGet(\node), REF ctx, fnRef:_fieldNameWalker),
\     E_cNoKey);
\   ret ft2(REF ctx); \ offset
\ )

$tAssertEq(0,       struct_fieldCtx(dnode:DNode) l -> drp\tyItem)
$tAssertEq(16\0x10, struct_fieldCtx(dnode:DNode) m -> drp\tyItem)

\ Walk a series of dots (a.foo.bar.baz), returning the last found node and
\ whether there are unrecognized symbols after the dot (i.e. struct field)
fn walkDots -> out(n: &DNode, isLast:U1) do (
  NULL\curNode
  LOOP l0
    dictRefMaybe(dup\curNode)  \ {prevNode curNode}
    if(not dup\curNode) do (
      drp\curNode; tokenPlcSet(0);
      ret(\prevNode, FALSE\isLast);
    )
    swp -> drp\prevNode; \ {curNode}
    if(scan; not tokenEq(SLC_DOT)) do ( \ check if next symbol is '.'
      tokenPlcSet(0);
      ret(\curNode, TRUE\isLast);
    )
    assert(isTyDict(dup\curNode), E_dot);
  AGAIN l0
)

fn bracketO do ret ( expectToken(SLC_BRACK_O, E_bracket) -> drp; )
fn bracketC do ret ( expectToken(SLC_BRACK_C, E_bracket) -> drp; )

\ offsetOf[MyStruct.myField]
syn fn offsetOf do ret (
  bracketO; walkDots -> assertNot(\isLast, E_type); \ {asNow &DNodeStruct}
  struct_fieldCtx(\dnode) -> drp\tyItem; bracketC;
  swp -> retIf(\asNow) -> jmp:L;
)
$tAssertEq(0, offsetOf[DNode.l])  $tAssertEq(16, offsetOf[DNode.m])

$NEW_BLOCK_PRIV

\ TODO: szOf[any.type]
