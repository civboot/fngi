$fngi  $STORE_PUB
\ Bootstraps the fngi language.
\ Requires: boot.sp
\
\ Note: at this stage the language is severely restricted and several
\ pieces of the language are incomplete. Any CAPITAL items like FN, IF, LOOP
\ etc do not behave in the way their lower-case counterparts will behave.
\ Refer to boot.sp for all documentation.

pub syn        FN dv      notNow; $c1(DV); jmp:h1(d_vGet(colonRef))
pub pre inline FN memSet  $h1(2) dv:DV_memSet  ret; \ [&dst v len]   "dst = v"
pub pre inline FN memCmp  $h1(2) dv:DV_memCmp  ret; \ [&dst &src len] "dst = src"
pub pre inline FN memMove $h1(2) dv:DV_memMove ret; \ [&a &b len -> cmp]
pub pre        FN memClr  0 swp; jmp:memSet(_, _) \ [&a len] clear

pub pre FN dictRefMaybe \ [&root -> &node(nullable)]
  scan;  DV_comp_dGet -> dv:DV_comp; ret; 

syn FN =  panic(E_cToken)    \ prevent hanging =
syn FN )  panic(E_cParen)    \ prevent hanging )

inline pre FN >     $h1(2) swp -> (_ < _)  ret;     \ [a b -> a > b]
inline pre FN <=    $h1(2) swp -> (_ >= _) ret;     \ [a b -> a <= b]
$tAssert(2 > 1) $tAssertNot(2 > 2) $tAssert(2 <= 2) $tAssertNot(2 <= 1)

inline pre FN le_s  $h1(2) swp -> (_ ge_s _)  ret;  \ [a b -> a <= b]
inline pre FN gt_s  $h1(2) swp -> (_ lt_s _)  ret;  \ [a b -> a >= b]
$tAssert(gt_s(neg 1, neg 2)) $tAssertNot(gt_s(neg 2, neg 2))
$tAssert(gt_s(2, neg 7))
$tAssert(le_s(neg 2, neg 2)) $tAssert(le_s(neg 3, neg 2))
$tAssert(le_s(neg 1, 100))

pub syn FN |  notNow; \ [-> dat len] Define a string slice
  h1(SZ1 + SLC); heap; h1(0); \ {start}
  LOOP l0  charNextEsc; \ {start, char, unknownEscape
    \ IF (\unknownEscape) assert(dup\char == 0c|, E_cStr);
    IF (\unknownEscape) assert(dup\char == 0c|, E_cStr);
    ELSE IF (dup\char == 0c|)
      drp\char; (heap - ovr\start) -> dec; \ {start len}
      assert(0xFF >= ovr\len, E_cNotFit);
      swp; sr1(\len, \start); ret;
    END END  h1(\char);
  AGAIN l0
$STORE_PRIV
FN helloWorld  ret |Hello World!|  \ [-> dat len]
$tAssertEq(helloWorld, 12); \ len == 12
$tAssertEq(ft1(dup\dat), 0cH);  $tAssertEq(ft1(inc(\dat)), 0ce); \ "He"

$STORE_PUB
pub pre FN slcCmp \ [&a aLen &b bLen -> cmp]
  $declVar(declL b,    TY_VAR_INPUT, RSIZE)
  $declVar(declL bLen, TY_VAR_INPUT, RSIZE)
  $declEnd
  IF(dup\aLen < GET bLen) drp; drp; ret(neg 1); END
  IF(   \aLen > GET bLen)      drp; ret(    1); END
  ret memCmp(\a, GET b, GET bLen)
pub pre FN slcEq  ret(slcCmp(_) == 0)
pub pre FN tokenEq ret(slcEq(_, tokenDat, tokenPlc))

$STORE_PRIV
FN helloBobby  ret |Hello Bobby!|  \ [-> dat len]
$tAssert   (slcEq(helloWorld, helloWorld))
$tAssertNot(slcEq(helloWorld, helloBobby))
$tAssertEq(slcCmp(helloWorld, helloWorld),     0) \ is equal
$tAssert(  slcCmp(helloWorld, 0, 42)      lt_s 0) \ different lengths
$tAssert(  slcCmp(helloWorld, helloBobby) gt_s 0) \ different contents

$STORE_PUB

pre FN expectToken \ [<token/s> slc -> &node(nullable)]
  $declVar(declL node, 0, RSIZE)  $declEnd
  dictRefMaybe(0) -> SET node; \ {slc}
  assert(tokenEq(\slc), E_cToken)
  ret GET node

FN SLC_DO    ret |do|
FN SLC_ELIF  ret |elif|
FN SLC_ELSE  ret |else|

FN _if \ [] recursive fn of `if`
  $declVar(declL h,    0, RSIZE) $declEnd
  scan; single(FALSE) \ compile token after `if`
  xx:IF(FALSE\asNow) -> SET h \ compile IF
  expectToken(SLC_DO) -> drp;
  scan; single(FALSE); \ compile token after `do`
  IF(scan; tokenEq(SLC_ELIF))
    xx:ELSE(GET h, FALSE\asNow) -> SET h;
    _if; \ recurse for next elif/else clause
  ELSE IF(tokenEq(SLC_ELSE))
    xx:ELSE(GET h, FALSE\asNow) -> SET h;
    scan; single(FALSE);
  ELSE tokenPlcSet(0); \ reset token (peeking)
  END END 
  ret _END(GET h, dup)

syn FN if  notNow; ret _if;

$STORE_PRIV
pre FN testIf2 \ [a -> b] converts 1->4, 2->7, else: 13
  if(dup == 1)  do (drp; ret 4)
  elif(\a == 2) do (     ret 7)
  ret (0x99)
$tAssertEq(testIf2(1), 4)      $tAssertEq(testIf2(2), 7)
$tAssertEq(testIf2(12), 0x99)  $assertNoWs

pre FN testManyElif \ [a -> b]
  $declVar(declL a,    TY_VAR_INPUT, RSIZE) $declEnd
  if   (GET a < 0x10) do ret(0x1000 + GET a)
  elif (GET a < 0x20) do ret(0x2000 + GET a)
  elif (GET a < 0x30) do ret(0x3000 + GET a)
  elif (GET a < 0x40) do    (0x4000 + GET a) \ note: fallthrough
  else ret(0x10 + GET a)
  ret inc(_)
$tAssertEq(testManyElif(0x5),  0x1005)
$tAssertEq(testManyElif(0x17), 0x2017)
$tAssertEq(testManyElif(0x22), 0x3022)
$tAssertEq(testManyElif(0x33), 0x4034)
$tAssertEq(testManyElif(0x55), 0x65)


$assertNoWs
