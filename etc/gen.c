#include <stddef.h>
#include <stdio.h>
#include <fcntl.h>
#include <assert.h>
#include <errno.h>
#include <string.h>
#include <unistd.h>

#include "../kernel/kernel.h"

#define sizeofField(TYPE, FIELD)   sizeof(((TYPE*)0)->FIELD)

U1* header = (
"\\ @file kernel/offsets.sp\n"
"\\ DO NOT EDIT MANUALLY! THIS FILE WAS GENERATED BY: etc/make.py\n"
"\\\n"
"\\ @brief Defines global variable offsets.\n"
"\n"
);

int writeto(U1* path) {
  int fd = open(path, O_WRONLY | O_CREAT | O_TRUNC, 00600); assert(fd); return fd;
}

#define WRITE_FIELD(TYPE, PRE, FIELD, COMMENT) \
    assert(dprintf(fd,                         \
        "#%.2X   #0=%-20s  \\ %s\n",            \
        offsetof(TYPE, FIELD),                 \
                PRE #FIELD, COMMENT))

#define WRITE_KERN(FD, FIELD)     WRITE_VAL(FD, #FIELD, offsetof(Kern, FIELD), "K_")
#define WRITE_FB(FD, FIELD)       WRITE_VAL(FD, #FIELD, offsetof(Fiber, FIELD), "Fb_")
#define WRITE_GLOBAL(FD, FIELD)   WRITE_VAL(FD, #FIELD, offsetof(Globals, FIELD), "G_")

void main() {
  int fd = writeto("kernel/offsets.sp");
  assert(dprintf(fd, header) > 0);
  assert(dprintf(fd, "\\ struct Kernel { ... }\n") > 0);
  WRITE_FIELD(Kern, "K_", memTop, "Ref: highest address in memory");
  WRITE_FIELD(Kern, "K_", ba, "BA struct: kernel BA");
  WRITE_FIELD(Kern, "K_", bbaPub, "BBA struct: kernel BBA");
  WRITE_FIELD(Kern, "K_", bbaPriv, "BBA struct: private BBA");
  WRITE_FIELD(Kern, "K_", dict, "&Dict: kernel dictionary");

  assert(dprintf(fd, "\n\\ struct Globals { ... }\n") > 0);
  WRITE_FIELD(Globals, "G_", glen, "U2");
  WRITE_FIELD(Globals, "G_", gcap, "U2");
  WRITE_FIELD(Globals, "G_", fb, "&Fiber: current fiber");
  WRITE_FIELD(Globals, "G_", cstate, "U2: compiler state");
  WRITE_FIELD(Globals, "G_", logLvlSys, "U1");
  WRITE_FIELD(Globals, "G_", logLvlUsr, "U1");
  WRITE_FIELD(Globals, "G_", metaNext, "U2: next function's m1 and m0");
  WRITE_FIELD(Globals, "G_", bbaPub, "&BBA: current public bba");
  WRITE_FIELD(Globals, "G_", bbaPriv, "&BBA: current private bba");
  WRITE_FIELD(Globals, "G_", srcM, "&FileMethods: src file methods");
  WRITE_FIELD(Globals, "G_", src, "&File: src File");

  assert(dprintf(fd, "\n\\ struct Fiber { ... }\n") > 0);
  WRITE_FIELD(Fiber, "Fb_", ws, "Stk struct: working stack");
  WRITE_FIELD(Fiber, "Fb_", gb, "&Globals: globals base pointer");
  WRITE_FIELD(Fiber, "Fb_", err, "U2: panic error");

  assert(dprintf(fd, "\n\\ BA { Ref nodes; Ref blocks; U1 rooti; U1 cap; }\n"));
  WRITE_FIELD(BA, "BA_", nodes, "&Node: start of nodes len cap*2");
  WRITE_FIELD(BA, "BA_", blocks, "&Block: start of 4k blocks len cap");
  WRITE_FIELD(BA, "BA_", rooti, "U1: root index");
  WRITE_FIELD(BA, "BA_", cap, "U1: number of nodes and blocks");

  assert(dprintf(fd, "\n\\ BBA { Ref ba; U1 rooti; U2 len; U2 cap; }\n"));
  WRITE_FIELD(BBA, "BBA_", ba, "&BA");
  WRITE_FIELD(BBA, "BBA_", rooti, "U1: owned block root index");
  WRITE_FIELD(BBA, "BBA_", len, "U2: unsigned heap");
  WRITE_FIELD(BBA, "BBA_", cap, "U2: signed topheap");

  assert(dprintf(fd, "\n\\ struct DNode { ... }\n") > 0);
// typedef struct { Ref l; Ref r; Ref ckey; U1 m0; U1 m1; U4 v; } DNode;
  WRITE_FIELD(DNode, "DN_", l, "Ref: left");
  WRITE_FIELD(DNode, "DN_", r, "Ref: right");
  WRITE_FIELD(DNode, "DN_", ckey, "Ref: counted data key");
  WRITE_FIELD(DNode, "DN_", m1, "U1: meta 1, kernel metadata");
  WRITE_FIELD(DNode, "DN_", m0, "U1: meta 0, type metadata");
  WRITE_FIELD(DNode, "DN_", v, "Ref: value, which may be a constant");

  assert(dprintf(fd, "\n") > 0); close(fd);
}
