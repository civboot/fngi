#include <stddef.h>
#include <stdio.h>
#include <fcntl.h>
#include <assert.h>
#include <errno.h>
#include <string.h>
#include <unistd.h>

#include "../boot/kernel.h"

#define sizeofField(TYPE, FIELD)   sizeof(((TYPE*)0)->FIELD)

U1* header = (
"\\ @file boot/offsets.sp\n"
"\\ DO NOT EDIT MANUALLY! THIS FILE WAS GENERATED BY: boot/make.py\n"
"\\\n"
"\\ @brief Defines global variable offsets.\n"
);

int writeto(U1* path) {
  int fd = open(path, O_WRONLY | O_CREAT | O_TRUNC, 00600); assert(fd); return fd;
}

#define WRITE_DIRECT(META, VALUE, NAME, COMMENT) \
    assert(dprintf(fd,                         \
        "#%.2X   #%X=%-20s  \\ %s\n",          \
        VALUE,    META,  \
                     NAME,     COMMENT))

#define WRITE_FIELD(META, TYPE, PRE, FIELD, COMMENT) \
    WRITE_DIRECT( \
      META, offsetof(TYPE, FIELD), PRE #FIELD, COMMENT)

#define WRITE_INDEX(TYPE, PRE, FIELD, COMMENT) \
  WRITE_DIRECT(0, offsetof(TYPE, FIELD) / RSIZE, PRE #FIELD, COMMENT)

void main() {
  int fd = writeto("boot/offsets.sp");
  assert(dprintf(fd, header) > 0);

  assert(dprintf(fd, "\n\\ struct Slc { ... }\n") > 0);
  WRITE_FIELD(0, Buf, "Slc_", dat, "Ref: data");
  WRITE_FIELD(0, Buf, "Slc_", len, "U2: length of buffer");

  assert(dprintf(fd, "\n\\ struct Globals { ... }\n") > 0);
  WRITE_FIELD(TY_VAR | SZ2, Globals, "G_", glen, "U2");
  WRITE_FIELD(TY_VAR | SZ2, Globals, "G_", gcap, "U2");
  WRITE_FIELD(TY_VAR | SZR, Globals, "G_", fb, "&Fiber: current fiber");
  WRITE_FIELD(TY_VAR | SZ2, Globals, "G_", cstate, "U2: compiler state");
  WRITE_FIELD(TY_VAR | SZ1, Globals, "G_", fnState, "U1: function compilation state");
  WRITE_FIELD(TY_VAR | SZ1, Globals, "G_", localOffset, "U1: current offset of locals");
  WRITE_FIELD(TY_VAR | SZ1, Globals, "G_", logLvlSys, "U1");
  WRITE_FIELD(TY_VAR | SZ1, Globals, "G_", logLvlUsr, "U1");
  WRITE_FIELD(TY_VAR | SZ2, Globals, "G_", metaNext, "U2: next function's meta");
  WRITE_FIELD(TY_VAR | SZR, Globals, "G_", curNode, "Ref: current compiling dict node");
  WRITE_FIELD(TY_VAR | SZR, Globals, "G_", compFn, "Ref: function used for compiling");
  WRITE_FIELD(TY_VAR | SZR, Globals, "G_", bbaLocal, "BBA: local BBA");
  WRITE_FIELD(TY_VAR | SZR, Globals, "G_", dictLocal, "&DNode: local dict");
  WRITE_FIELD(TY_VAR | SZR, Globals, "G_", bbaPub, "&BBA: current public bba");
  WRITE_FIELD(TY_VAR | SZR, Globals, "G_", bbaPriv, "&BBA: current private bba");
  WRITE_FIELD(TY_VAR | SZR, Globals, "G_", dictStk, "Stk: stack of dictionary references");
  WRITE_FIELD(TY_VAR | SZR, Globals, "G_", srcM, "&FileMethods: src file methods");
  WRITE_FIELD(TY_VAR | SZR, Globals, "G_", src, "&File: src File");

  assert(dprintf(fd, "\n\\ struct File { ... }\n") > 0);
  WRITE_FIELD(0, File, "Fs_", buf, "Buf: buffer");
  WRITE_FIELD(0, File, "Fs_", plc, "U2: plc in buffer");

  assert(dprintf(fd, "\n\\ BBA methods:\n"));
  WRITE_INDEX(BBAMethods, "BBAm_", bump, "method index");
  WRITE_INDEX(BBAMethods, "BBAm_", newBlock, "method index");
  WRITE_INDEX(BBAMethods, "BBAm_", drop, "method index");

  assert(dprintf(fd, "\n\\ struct DNode { ... }\n") > 0);
// typedef struct { Ref l; Ref r; Ref ckey; U2 m; U4 v; } DNode;
  WRITE_FIELD(0, DNode, "DN_", l, "Ref: left");
  WRITE_FIELD(0, DNode, "DN_", r, "Ref: right");
  WRITE_FIELD(0, DNode, "DN_", ckey, "Ref: counted data key");
  WRITE_FIELD(0, DNode, "DN_", m, "U2: meta");
  WRITE_FIELD(0, DNode, "DN_", v, "Ref: value, which may be a constant");
  WRITE_DIRECT(0, sizeof(DNode), "DN_ty", "Ref?: only exists if C_TYPED");

  assert(dprintf(fd, "\n") > 0); close(fd);
}
