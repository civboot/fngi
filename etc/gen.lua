require('gciv')

local CONST_PAT = (
  'const%s+([_%w]+)%s*:'
  .. '%s*([_%w]+)%s*='
  .. '%s*([_%w]+)'
)
local STRUCT_PAT = 'struct%s+(%w+)%s*(%b[])'
local TY_PAT = '(&*)%s*(%w+)'
local FIELD_PAT = '(%w+)%s*:%s*' .. TY_PAT

local NATIVE_TYS = Set{"U1", "U2", "U4", "S", "I1", "I2", "I4"}

local RENAME = {
    Arena  = "SpArena",
    Reader = "SpReader",
    Writer = "SpWriter",
    Fmt    = "SpFmt",
    Logger = "SpLogger",
}

local tyDictDefined = false

local FConst = struct('FConst', {'name', 'ty', 'value'})
-- Const: {name, ty, value}
local function parseConsts(s, to)
  if not to then 
    to = Map{} end
  for name, ty, value in string.gmatch(s, CONST_PAT) do
    to[name] = FConst{name=name, ty=ty, value=value}
  end
  return to
end

local FField = struct('', {
  {'name', String}, {'refs', Int}, {'ty', String}
})
local FStruct = struct('FStruct', {
  {'name', String}, {'fields', List}
})

local function parseStructs(s, to)
  if not to then to = Map{} end
  for sname, body in string.gmatch(s, STRUCT_PAT) do
    local fields = List{}
    for name, refs, ty in string.gmatch(body, FIELD_PAT) do
      if name == 'parent' then fields:extend(to[ty].fields)
      else
        fields:add(FField{
          name=name, refs=string.len(refs), ty=ty
        })
      end
    end
    to[sname] = FStruct{name=sname, fields=fields}
  end
  return to
end

local function parseFngi(path, to)
  local text = readAll(path)
  if not to then
    to = Map{consts=Map{}, structs=Map{}}
  end
  parseConsts(text,  to.consts)
  parseStructs(text, to.structs)
  return to
end

local spor = parseFngi('src/spor.fn')
local dat = parseFngi('src/dat.fn')
local datStructs = copy(dat.structs)
parseFngi('src/comp.fn', dat)
local compStructs = dat.structs:diff(datStructs)

local function genConsts(b, path, consts)
  b:add('// DO NOT EDIT MANUALLY! GENERATED BY etc/gen.py\n')
  b:add('// See docs at: ' .. path .. '\n')
  b:add('#include "civ.h"\n\n')
  for k, c in pairs(consts) do
    b:add('#define ' .. k .. '  ' .. c.value .. '\n')
  end
  return b
end

local DECLARE = [=====[
struct _TyDict;
struct _TyFn;

typedef struct {
  struct _TyFn*  drop;     // this:&This -> ()
  struct _TyFn*  alloc;    // this:&This sz:S alignment:U2 -> Ref
  struct _TyFn*  free;     // this:&This dat:Ref sz:S alignment:U2 -> ()
  struct _TyFn*  maxAlloc; // this:&This -> S
} MSpArena;
typedef struct { void* d; MSpArena* m; } SpArena;

typedef struct {
  struct _TyFn*  read;   // this:&This -> ()
  struct _TyFn*  asBase; // this:&This -> &BaseFile
} MSpReader;
typedef struct { void* d; MSpReader* m; } SpReader;

typedef struct {
  struct _TyFn*  asBase; // this:&This -> &BaseFile
  struct _TyFn*  write;  // this:&This -> ()
} MSpWriter;
typedef struct { void* d; MSpWriter* m; } SpWriter;

typedef struct {
  MSpWriter w;
  struct _TyFn*  state;  // this:&This -> &FmtState
} MSpFmt;
typedef struct { void* d; MSpFmt* m; } SpFmt;

typedef struct {
  MSpFmt         fmt;
  struct _TyFn*  logConfig;  // this:&This -> &LogConfig

  struct _TyFn*  start;      // this:&This U1  -> U1
  struct _TyFn*  add;        // this:&This Slc -> ()
  struct _TyFn*  end;        // this:&This     -> ()
} MSpLogger;
typedef struct { void* d; MSpLogger* m; } SpLogger;
]=====]


print(concat(genConsts(List{}, 'mypath', spor.consts)))
error('')

return {
  parseConsts = parseConsts,
  parseStructs = parseStructs,
  STRUCT_PAT = STRUCT_PAT,
  FIELD_PAT = FIELD_PAT,
  FConst = FConst, FField = FField, FStruct = FStruct,
  spor = spor, dat = dat,
  datStructs = datStructs, compStructs = compStructs,

  genConsts = genConsts,
}
